/*!
 * 
 *          ekmap-mapboxgl.(https://ekgis.com.vn/)
 *          Copyright© 2009 - 2020 eKGIS
 *          license: Apache-2.0
 *          version: v0.0.1
 *         
 */!function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=0)}({"./node_modules/node-libs-browser/node_modules/events/events.js":function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar R = (typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\n\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\n\nmodule.exports = EventEmitter;\nmodule.exports.once = once; // Backwards-compat with node 0.10.x\n\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\n\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + _typeof(listener));\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function get() {\n    return defaultMaxListeners;\n  },\n  set: function set(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}; // Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n\n\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }\n\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    } // At least give some kind of context to the user\n\n\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      ReflectApply(listeners[i], this, args);\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n\n      events = target._events;\n    }\n\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    } // Check for listener leak\n\n\n    m = _getMaxListeners(target);\n\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true; // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n}; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n\n    return this;\n  } // emit removeListener for all listeners on all events\n\n\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    copy[i] = arr[i];\n  }\n\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) {\n    list[index] = list[index + 1];\n  }\n\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n\n      resolve([].slice.call(arguments));\n    }\n\n    ;\n    var errorListener; // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/events/events.js?")},"./src/mapboxgl/control/FeatureInfomation.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FeatureInfomation\", function() { return FeatureInfomation; });\n/* harmony import */ var _services_MapService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../services/MapService */ \"./src/mapboxgl/services/MapService.js\");\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/mapboxgl/core/Base.js\");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mapbox-gl */ \"mapbox-gl\");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_2__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.control.FeatureInfomation\r\n * @category  Control\r\n * @classdesc FeatureInfomation.\r\n * @param {Object} options Construction parameters.\r\n * @param {Boolean} options.setStyle=true If setStyle = false, the selected feature will not set style and vice versa it will set style default.\r\n * @extends {mapboxgl.Evented}\r\n * @fires mapboxgl.ekmap.FeatureInfomation#selectfeatures\r\n * @example\r\n * (start code)\r\n *  map.addControl(new mapboxgl.ekmap.control.FeatureInfomation({ setStyle: true }),'bottom-right');\r\n * (end)\r\n */\n\nvar FeatureInfomation = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(FeatureInfomation, _mapboxgl$Evented);\n\n  var _super = _createSuper(FeatureInfomation);\n\n  function FeatureInfomation(options) {\n    var _this;\n\n    _classCallCheck(this, FeatureInfomation);\n\n    _this = _super.call(this, options);\n    _this.options = options ? options : {};\n    _this.setStyle = options ? options.setStyle : true;\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.control.FeatureInfomation.prototype.onAdd\r\n   * @description Register a control on the map and give it a chance to register event listeners and resources. This method is called by Map#addControl internally.\r\n   * @param {Map} map the Map this control will be added to.\r\n   * @returns {HTMLElement}  The control's container element. This should be created by the control and returned by onAdd without being attached to the DOM: the map will insert the control's element into the DOM as necessary.\r\n   */\n\n\n  _createClass(FeatureInfomation, [{\n    key: \"onAdd\",\n    value: function onAdd(map) {\n      this._map = map;\n      this._container = document.createElement('div');\n      this._container.className = 'mapboxgl-ctrl';\n      var me = this;\n\n      this._map.on('click', function (e) {\n        var layers = me._map.getStyle().layers;\n\n        layers.forEach(function (layer) {\n          if (layer.metadata && layer.metadata.type == 'overlayer' && layer.layout.visibility === \"visible\") {\n            var mapService = new mapbox_gl__WEBPACK_IMPORTED_MODULE_2___default.a.ekmap.MapService({\n              url: layer.metadata.url,\n              token: layer.metadata.token\n            });\n            mapService.identify().on(me._map).at(e.lngLat).run(function (obj) {\n              var features = [];\n\n              if (obj.length > 0 && me.setStyle) {\n                for (var i = 0; i < obj.length; i++) {\n                  //Point\n                  if (obj[i].geometryType == 'esriGeometryPoint') {\n                    features.push({\n                      'type': 'Feature',\n                      'geometry': {\n                        'type': 'Point',\n                        'coordinates': [obj[i].geometry.x, obj[i].geometry.y]\n                      },\n                      'properties': {\n                        'name': 'point'\n                      }\n                    });\n                  } else {\n                    var coordinates;\n                    if (obj[i].geometry.paths) coordinates = obj[i].geometry.paths[0];else coordinates = obj[i].geometry.rings[0];\n                    if (obj[i].geometryType == 'esriGeometryPolyline') features.push({\n                      'type': 'Feature',\n                      'geometry': {\n                        'type': 'LineString',\n                        'coordinates': coordinates\n                      },\n                      'properties': {\n                        'name': 'line'\n                      }\n                    });else features.push({\n                      'type': 'Feature',\n                      'geometry': {\n                        'type': 'LineString',\n                        'coordinates': coordinates\n                      },\n                      'properties': {\n                        'name': 'area'\n                      }\n                    });\n                  }\n\n                  var data = {\n                    'type': 'FeatureCollection',\n                    'features': features\n                  };\n\n                  if (!me._map.getSource('feature-info')) {\n                    me._map.addSource('feature-info', {\n                      'type': 'geojson',\n                      'data': data\n                    });\n\n                    me._map.addLayer({\n                      'id': 'point',\n                      'type': 'circle',\n                      'source': 'feature-info',\n                      'paint': {\n                        'circle-radius': 10,\n                        'circle-color': '#0000ff'\n                      },\n                      'filter': ['in', 'name']\n                    });\n\n                    me._map.addLayer({\n                      'id': 'line',\n                      'type': 'line',\n                      'source': 'feature-info',\n                      'layout': {\n                        'line-join': 'round',\n                        'line-cap': 'round'\n                      },\n                      'paint': {\n                        'line-color': '#000',\n                        'line-width': 5\n                      },\n                      'filter': ['in', 'name']\n                    });\n\n                    me._map.addLayer({\n                      'id': 'area',\n                      'type': 'fill',\n                      'source': 'feature-info',\n                      'layout': {},\n                      'paint': {\n                        'fill-outline-color': '#484896',\n                        'fill-color': '#6e599f',\n                        'fill-opacity': 0.75\n                      },\n                      'filter': ['in', 'name']\n                    });\n\n                    me.setFilter(me._map);\n                  } else {\n                    me._map.getSource('feature-info').setData(data);\n\n                    me.setFilter(me._map);\n                  }\n\n                  if (me._map.getLayer('point') && me._map.getLayer('line')) me._map.moveLayer('line', 'point');\n                }\n\n                obj.coordinate = e.lngLat;\n              }\n              /**\r\n               * @event mapboxgl.ekmap.control.FeatureInfomation#selectfeatures\r\n               * @description Fired when the feature is selected.\r\n               */\n\n\n              me.fire('selectfeatures', obj);\n            }, \"\");\n          }\n        });\n      });\n\n      return this._container;\n    }\n    /**\r\n     * @private\r\n     * @param {*} map \r\n     */\n\n  }, {\n    key: \"setFilter\",\n    value: function setFilter(map) {\n      map.setFilter('point', ['in', 'name', 'point']);\n      map.setFilter('line', ['in', 'name', 'line']);\n      map.setFilter('area', ['in', 'name', 'area']);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.control.FeatureInfomation.prototype.onRemove\r\n     * @description Unregister a control on the map and give it a chance to detach event listeners and resources. This method is called by Map#removeControl internally.\r\n     * @param {Map} map the Map this control will be removed from.\r\n     * @returns {undefined}  there is no required return value for this method.\r\n     */\n\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this._container.parentNode.removeChild(this._container);\n\n      this._map = undefined;\n    }\n  }, {\n    key: \"removeLayer\",\n    value: function removeLayer(map) {\n      if (map) {\n        if (map.getLayer('point')) {\n          map.removeLayer('point');\n          map.removeSource('point');\n        }\n\n        if (map.getLayer('line')) {\n          map.removeLayer('line');\n          map.removeSource('line');\n        }\n\n        if (map.getLayer('area')) {\n          map.removeLayer('area');\n          map.removeSource('area');\n        }\n      }\n    }\n  }]);\n\n  return FeatureInfomation;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_2___default.a.Evented);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_2___default.a.ekmap.control.FeatureInfomation = FeatureInfomation;\n\n//# sourceURL=webpack:///./src/mapboxgl/control/FeatureInfomation.js?")},"./src/mapboxgl/control/Legend.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Legend", function() { return Legend; });\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base */ "./src/mapboxgl/core/Base.js");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Util */ "./src/mapboxgl/core/Util.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.control.Legend\r\n * @category  Control\r\n * @classdesc Legend.\r\n * @param {Object} options Construction parameters.\r\n * @param {Array<mapboxgl.Map>} options.layers List of layers for which you want to display legend.\r\n * @param {string} options.target Specify a target if you want the control to be rendered outside of the map\'s viewport.</br> If target is equal to null or undefined, control will render by default. \r\n *\r\n * @example\r\n *  var map = new mapboxgl.Map({\r\n *      //config....\r\n *  });\r\n *  var tiledMap = new mapboxgl.ekmap.TiledMapLayer({\r\n *       url: \'https://viegisserver.ekgis.vn/gserver/rest/services/35/MapServer\'\r\n *  }).addTo(map);\r\n *  var legend = new mapboxgl.ekmap.control.Legend({\r\n *      layers: [tiledMap]\r\n *  });\r\n *  map.addControl(legend,"top-left");\r\n */\n\nvar Legend = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(Legend, _mapboxgl$Evented);\n\n  var _super = _createSuper(Legend);\n\n  function Legend(options) {\n    var _this;\n\n    _classCallCheck(this, Legend);\n\n    _this = _super.call(this, options);\n    _this.options = options ? options : {};\n    _this.layers = _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].isArray(_this.options.layers) ? _this.options.layers : [_this.options.layers];\n    _this.target = _this.options.target;\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.control.Legend.prototype.onAdd\r\n   * @description Register a control on the map and give it a chance to register event listeners and resources. This method is called by Map#addControl internally.\r\n   * @param {Map} map the Map this control will be added to.\r\n   * @returns {HTMLElement}  The control\'s container element. This should be created by the control and returned by onAdd without being attached to the DOM: the map will insert the control\'s element into the DOM as necessary.\r\n   */\n\n\n  _createClass(Legend, [{\n    key: "onAdd",\n    value: function onAdd(map) {\n      this._map = map;\n      var me = this; //might use this later\n\n      if (!this.target) {\n        this.button = document.createElement("button");\n        var icon = document.createElement("i");\n        icon.className = "fa fa-bars";\n        this.button.className = "mapboxgl-ctrl-zoom-in";\n        this.button.appendChild(icon);\n        this.button.addEventListener("click", function (e) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          if (me._panel) {\n            me._div.removeChild(me._panel);\n          }\n\n          me.button.style.display = "none";\n          me._panel = me.createLayerInputToggle();\n\n          me._div.appendChild(me._panel);\n        });\n      } else {\n        this.button = document.getElementById(this.target);\n        this.button.addEventListener("click", function (e) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          if (me._panel) {\n            me._div.removeChild(me._panel);\n          }\n\n          me.button.style.display = "none";\n          me._panel = me.createLayerInputToggle();\n\n          me._div.appendChild(me._panel);\n        });\n      }\n\n      this._div = document.createElement(\'div\');\n\n      this._div.setAttribute("id", "container");\n\n      me._div.style.overflow = "auto";\n      me._div.style.overflowX = "hidden";\n      me._div.style.fontSize = "14px";\n      me._div.style.background = "#fff";\n      this._div.className = \'mapboxgl-ctrl mapboxgl-ctrl-group\'; //this._div.style.padding = "8px";\n\n      $(document).click(function (event) {\n        if (!$(event.target).closest(\'#container\').length) {\n          me.close();\n        }\n      });\n\n      this._div.appendChild(this.button);\n\n      return this._div;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.control.Legend.prototype.onRemove\r\n     * @description Unregister a control on the map and give it a chance to detach event listeners and resources. This method is called by Map#removeControl internally.\r\n     * @param {Map} map the Map this control will be removed from.\r\n     * @returns {undefined}  there is no required return value for this method.\r\n     */\n\n  }, {\n    key: "onRemove",\n    value: function onRemove(map) {\n      this._map = map;\n\n      this._div.parentNode.removeChild(this._div);\n\n      this._map = undefined;\n    }\n    /**\r\n    * @private\r\n    * @description Create layer input\r\n    */\n\n  }, {\n    key: "createLayerInputToggle",\n    value: function createLayerInputToggle() {\n      var me = this;\n      var div = document.createElement("div");\n      div.style.maxHeight = "300px";\n      div.style.padding = "1rem";\n      this.closeButton = document.createElement(\'a\');\n      this.closeButton.style.position = \'absolute\';\n      this.closeButton.style.top = \'0\';\n      this.closeButton.style.right = \'0\';\n      this.imgClose = document.createElement(\'img\');\n      this.imgClose.setAttribute("src", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEUAAACCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4OCg4MVktI5AAAAMnRSTlMAAQIDBAUGBwgJCg0ODxARJXV7hYiLj5GUmJ6go6aqsrS1w8XIytHT19nc4ubo6ev5+yWLQbAAAABzSURBVBgZncFHEoJAAATA2YBgFhQTBpBkAnX+/zjZpSiult34xeasYfmFgnHkRaOx5EvBkAlTDaxYz9CSMTMvZDVFR8b88DlBz3mTC/TEnuR1iI448DaPeB+hJU8sXIgdH2NYEfMBGmtWCsY2cWAFpcI/vj+FCU1mGENhAAAAAElFTkSuQmCC");\n      this.imgClose.style.padding = \'5px\';\n      this.imgClose.style.cursor = \'pointer\';\n      this.closeButton.appendChild(this.imgClose);\n      div.appendChild(this.closeButton);\n      this.closeButton.addEventListener("click", function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n        me.close();\n      });\n      var ul = document.createElement("ul");\n      ul.style.padding = "10px";\n      ul.style.margin = "0";\n      ul.style.listStyleType = "none";\n      this.layers.forEach(function (layer) {\n        layer.legend(function (list) {\n          var listLenged = list.layers.slice();\n\n          for (var i = 0; i < listLenged.length; i++) {\n            var li = document.createElement("li");\n            var strong = document.createElement("strong");\n            strong.innerHTML = listLenged[i].layerName;\n            li.appendChild(strong);\n\n            for (var j = 0; j < listLenged[i].legend.length; j++) {\n              var img = document.createElement("img");\n              img.width = 13;\n              img.height = 13;\n              img.src = "data:image/png;base64," + listLenged[i].legend[j].imageData;\n              var span = document.createElement("span");\n              span.innerHTML = listLenged[i].legend[j].label;\n              span.style.paddingLeft = \'15px\';\n              var li1 = document.createElement("li");\n              li1.appendChild(img);\n              li1.appendChild(span);\n              var ul1 = document.createElement("ul");\n              ul1.style.padding = "0";\n              ul1.style.margin = "0";\n              ul1.style.listStyleType = "none";\n              ul1.style.marginLeft = "15px";\n              ul1.appendChild(li1);\n              li.appendChild(ul1);\n              ul.appendChild(li);\n              div.appendChild(ul);\n            }\n          }\n        });\n      });\n      return div;\n    }\n    /**\r\n    * @private\r\n    * @description Close layer input\r\n    */\n\n  }, {\n    key: "close",\n    value: function close() {\n      if (this._panel) {\n        this._div.removeChild(this._panel);\n\n        this._panel = null;\n      }\n\n      this.button.style.display = "";\n    }\n  }]);\n\n  return Legend;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.Evented);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.control.Legend = Legend;\n\n//# sourceURL=webpack:///./src/mapboxgl/control/Legend.js?')},"./src/mapboxgl/control/SnapShot.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SnapShot", function() { return SnapShot; });\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base */ "./src/mapboxgl/core/Base.js");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/**\r\n * @class mapboxgl.ekmap.control.SnapShot\r\n * @category  Control\r\n * @classdesc SnapShot.\r\n *\r\n * @example\r\n *  var map = new mapboxgl.Map({\r\n *      //config....\r\n *  })\r\n *  map.addControl(new mapboxgl.ekmap.control.SnapShot(),\'bottom-right\');\r\n */\n\nvar SnapShot = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(SnapShot, _mapboxgl$Evented);\n\n  var _super = _createSuper(SnapShot);\n\n  function SnapShot() {\n    _classCallCheck(this, SnapShot);\n\n    return _super.call(this);\n  }\n  /**\r\n   * @function mapboxgl.ekmap.control.SnapShot.prototype.onAdd\r\n   * @description Register a control on the map and give it a chance to register event listeners and resources. This method is called by Map#addControl internally.\r\n   * @param {Map} map the Map this control will be added to.\r\n   * @returns {HTMLElement}  The control\'s container element. This should be created by the control and returned by onAdd without being attached to the DOM: the map will insert the control\'s element into the DOM as necessary.\r\n   */\n\n\n  _createClass(SnapShot, [{\n    key: "onAdd",\n    value: function onAdd(map) {\n      this._map = map;\n      var me = this; //might use this later\n\n      this._div = document.createElement(\'div\');\n      this._div["aria-label"] = "Chụp màn hình";\n      this._div.title = "Chụp màn hình";\n      this._div.className = \'mapboxgl-ctrl mapboxgl-ctrl-group\'; //this._div.style.padding = "8px";\n\n      this._div.style.fontSize = "14px";\n      var input = this.createLayerInputToggle(\'Long\', true, \'test\', "");\n\n      this._div.appendChild(input);\n\n      this._div.addEventListener("click", function (e) {\n        var nameImg = \'map_\' + me.guid12() + \'.png\';\n\n        me._map.getCanvas().toBlob(function (blob) {\n          saveAs(blob, nameImg);\n        });\n      });\n\n      return this._div;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.control.SnapShot.prototype.onRemove\r\n     * @description Unregister a control on the map and give it a chance to detach event listeners and resources. This method is called by Map#removeControl internally.\r\n     * @param {Map} map the Map this control will be removed from.\r\n     * @returns {undefined}  there is no required return value for this method.\r\n     */\n\n  }, {\n    key: "onRemove",\n    value: function onRemove(map) {\n      this._map = map;\n\n      this._div.parentNode.removeChild(this._div);\n\n      this._map = undefined;\n    }\n    /**\r\n    * @private\r\n    * @description Create layer input\r\n    */\n\n  }, {\n    key: "createLayerInputToggle",\n    value: function createLayerInputToggle() {\n      var button = document.createElement("button");\n      var icon = document.createElement("i");\n      icon.className = "fa fa-camera";\n      button.className = "mapboxgl-ctrl-zoom-in";\n      button.appendChild(icon);\n      return button;\n    }\n    /**\r\n    * @private\r\n    * @description Create id\r\n    */\n\n  }, {\n    key: "guid12",\n    value: function guid12() {\n      function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n      }\n\n      return s4() + s4() + s4();\n    }\n  }]);\n\n  return SnapShot;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.Evented);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.control.SnapShot = SnapShot;\n\n//# sourceURL=webpack:///./src/mapboxgl/control/SnapShot.js?')},"./src/mapboxgl/control/Swipe.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Swipe\", function() { return Swipe; });\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Base */ \"./src/mapboxgl/core/Base.js\");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mapbox-gl */ \"mapbox-gl\");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/node-libs-browser/node_modules/events/events.js\").EventEmitter;\n\nvar Swipe = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(Swipe, _mapboxgl$Evented);\n\n  var _super = _createSuper(Swipe);\n\n  function Swipe(a, b, container, options) {\n    var _this;\n\n    _classCallCheck(this, Swipe);\n\n    _this = _super.call(this);\n    _this.options = options ? options : {};\n    _this._mapA = a;\n    _this._mapB = b;\n    _this._horizontal = _this.options.orientation === 'horizontal';\n    _this._onDown = _this._onDown.bind(_assertThisInitialized(_this));\n    _this._onMove = _this._onMove.bind(_assertThisInitialized(_this));\n    _this._onMouseUp = _this._onMouseUp.bind(_assertThisInitialized(_this));\n    _this._onTouchEnd = _this._onTouchEnd.bind(_assertThisInitialized(_this));\n    _this._ev = new EventEmitter();\n    _this._swiper = document.createElement('div');\n    _this._swiper.className = _this._horizontal ? 'compare-swiper-horizontal' : 'compare-swiper-vertical';\n    _this._controlContainer = document.createElement('div');\n    _this._controlContainer.className = _this._horizontal ? 'mapboxgl-compare mapboxgl-compare-horizontal' : 'mapboxgl-compare';\n    _this._controlContainer.className = _this._controlContainer.className;\n\n    _this._controlContainer.appendChild(_this._swiper);\n\n    if (typeof container === 'string' && document.body.querySelectorAll) {\n      // get container with a selector\n      var appendTarget = document.body.querySelectorAll(container)[0];\n\n      if (!appendTarget) {\n        throw new Error('Cannot find element with specified container selector.');\n      }\n\n      appendTarget.appendChild(_this._controlContainer);\n    } else if (container instanceof Element && container.appendChild) {\n      // get container directly\n      container.appendChild(_this._controlContainer);\n    } else {\n      throw new Error('Invalid container specified. Must be CSS selector or HTML element.');\n    }\n\n    _this._bounds = b.getContainer().getBoundingClientRect();\n    var swiperPosition = (_this._horizontal ? _this._bounds.height : _this._bounds.width) / 2;\n\n    _this._setPosition(swiperPosition);\n\n    _this._onResize = function () {\n      this._bounds = b.getContainer().getBoundingClientRect();\n      if (this.currentPosition) this._setPosition(this.currentPosition);\n    }.bind(_assertThisInitialized(_this));\n\n    b.on('resize', _this._onResize);\n\n    if (_this.options && _this.options.mousemove) {\n      a.getContainer().addEventListener('mousemove', _this._onMove);\n      b.getContainer().addEventListener('mousemove', _this._onMove);\n    }\n\n    _this._swiper.addEventListener('mousedown', _this._onDown);\n\n    _this._swiper.addEventListener('touchstart', _this._onDown);\n\n    return _this;\n  }\n\n  _createClass(Swipe, [{\n    key: \"_onDown\",\n    value: function _onDown(e) {\n      if (e.touches) {\n        document.addEventListener('touchmove', this._onMove);\n        document.addEventListener('touchend', this._onTouchEnd);\n      } else {\n        document.addEventListener('mousemove', this._onMove);\n        document.addEventListener('mouseup', this._onMouseUp);\n      }\n    }\n  }, {\n    key: \"_setPointerEvents\",\n    value: function _setPointerEvents(v) {\n      this._controlContainer.style.pointerEvents = v;\n      this._swiper.style.pointerEvents = v;\n    }\n  }, {\n    key: \"_setPosition\",\n    value: function _setPosition(x) {\n      x = Math.min(x, this._horizontal ? this._bounds.height : this._bounds.width);\n      var pos = this._horizontal ? 'translate(0, ' + x + 'px)' : 'translate(' + x + 'px, 0)';\n      this._controlContainer.style.transform = pos;\n      this._controlContainer.style.WebkitTransform = pos;\n      var clipA = this._horizontal ? 'rect(0, 999em, ' + x + 'px, 0)' : 'rect(0, ' + x + 'px, ' + this._bounds.height + 'px, 0)';\n      var clipB = this._horizontal ? 'rect(' + x + 'px, 999em, ' + this._bounds.height + 'px,0)' : 'rect(0, 999em, ' + this._bounds.height + 'px,' + x + 'px)';\n      this._mapA.getContainer().style.clip = clipA;\n      this._mapB.getContainer().style.clip = clipB;\n      this.currentPosition = x;\n    }\n  }, {\n    key: \"_onMove\",\n    value: function _onMove(e) {\n      if (this.options && this.options.mousemove) {\n        this._setPointerEvents(e.touches ? 'auto' : 'none');\n      }\n\n      this._horizontal ? this._setPosition(this._getY(e)) : this._setPosition(this._getX(e));\n    }\n  }, {\n    key: \"_onMouseUp\",\n    value: function _onMouseUp() {\n      document.removeEventListener('mousemove', this._onMove);\n      document.removeEventListener('mouseup', this._onMouseUp);\n      this.fire('slideend', {\n        currentPosition: this.currentPosition\n      });\n    }\n  }, {\n    key: \"_onTouchEnd\",\n    value: function _onTouchEnd() {\n      document.removeEventListener('touchmove', this._onMove);\n      document.removeEventListener('touchend', this._onTouchEnd);\n      this.fire('slideend', {\n        currentPosition: this.currentPosition\n      });\n    }\n  }, {\n    key: \"_getX\",\n    value: function _getX(e) {\n      e = e.touches ? e.touches[0] : e;\n      var x = e.clientX - this._bounds.left;\n      if (x < 0) x = 0;\n      if (x > this._bounds.width) x = this._bounds.width;\n      return x;\n    }\n  }, {\n    key: \"_getY\",\n    value: function _getY(e) {\n      e = e.touches ? e.touches[0] : e;\n      var y = e.clientY - this._bounds.top;\n      if (y < 0) y = 0;\n      if (y > this._bounds.height) y = this._bounds.height;\n      return y;\n    }\n  }, {\n    key: \"setSlider\",\n    value: function setSlider(x) {\n      this._setPosition(x);\n    }\n  }, {\n    key: \"on\",\n    value: function on(type, fn) {\n      this._ev.on(type, fn);\n\n      return this;\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(type, data) {\n      this._ev.emit(type, data);\n\n      return this;\n    }\n  }, {\n    key: \"off\",\n    value: function off(type, fn) {\n      this._ev.removeListener(type, fn);\n\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      this._clearSync();\n\n      this._mapB.off('resize', this._onResize);\n\n      var aContainer = this._mapA.getContainer();\n\n      if (!!aContainer) {\n        aContainer.style.clip = null;\n        aContainer.removeEventListener('mousemove', this._onMove);\n      }\n\n      var bContainer = this._mapB.getContainer();\n\n      if (!!bContainer) {\n        bContainer.style.clip = null;\n        bContainer.removeEventListener('mousemove', this._onMove);\n      }\n\n      this._swiper.removeEventListener('mousedown', this._onDown);\n\n      this._swiper.removeEventListener('touchstart', this._onDown);\n\n      this._controlContainer.remove();\n    }\n  }]);\n\n  return Swipe;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.Evented);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.control.Swipe = Swipe;\n\n//# sourceURL=webpack:///./src/mapboxgl/control/Swipe.js?")},"./src/mapboxgl/control/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SnapShot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SnapShot */ "./src/mapboxgl/control/SnapShot.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SnapShot", function() { return _SnapShot__WEBPACK_IMPORTED_MODULE_0__["SnapShot"]; });\n\n/* harmony import */ var _Swipe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Swipe */ "./src/mapboxgl/control/Swipe.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Swipe", function() { return _Swipe__WEBPACK_IMPORTED_MODULE_1__["Swipe"]; });\n\n/* harmony import */ var _FeatureInfomation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FeatureInfomation */ "./src/mapboxgl/control/FeatureInfomation.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FeatureInfomation", function() { return _FeatureInfomation__WEBPACK_IMPORTED_MODULE_2__["FeatureInfomation"]; });\n\n/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Legend */ "./src/mapboxgl/control/Legend.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Legend", function() { return _Legend__WEBPACK_IMPORTED_MODULE_3__["Legend"]; });\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/mapboxgl/control/index.js?')},"./src/mapboxgl/core/Base.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * @namespace mapboxgl\r\n * @category BaseType Namespace\r\n */\n\n/**\r\n * @namespace mapboxgl.ekmap\r\n * @category BaseType Namespace\r\n */\n\n/**\r\n * @namespace mapboxgl.ekmap.control\r\n * @category BaseType Namespace\r\n */\n //thay đổi nội dung\n\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap = mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap || {};\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.control = mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.control || {};\n\n//# sourceURL=webpack:///./src/mapboxgl/core/Base.js?')},"./src/mapboxgl/core/Parse.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parse\", function() { return Parse; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Parse = /*#__PURE__*/function () {\n  function Parse() {\n    _classCallCheck(this, Parse);\n  }\n\n  _createClass(Parse, null, [{\n    key: \"arcgisToGeoJSON\",\n    value: function (_arcgisToGeoJSON) {\n      function arcgisToGeoJSON(_x, _x2) {\n        return _arcgisToGeoJSON.apply(this, arguments);\n      }\n\n      arcgisToGeoJSON.toString = function () {\n        return _arcgisToGeoJSON.toString();\n      };\n\n      return arcgisToGeoJSON;\n    }(function (arcgis, idAttribute) {\n      var geojson = {};\n\n      if (arcgis.features) {\n        geojson.type = 'FeatureCollection';\n        geojson.features = [];\n\n        for (var i = 0; i < arcgis.features.length; i++) {\n          geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));\n        }\n      }\n\n      if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {\n        geojson.type = 'Point';\n        geojson.coordinates = [arcgis.x, arcgis.y];\n\n        if (typeof arcgis.z === 'number') {\n          geojson.coordinates.push(arcgis.z);\n        }\n      }\n\n      if (arcgis.points) {\n        geojson.type = 'MultiPoint';\n        geojson.coordinates = arcgis.points.slice(0);\n      }\n\n      if (arcgis.paths) {\n        if (arcgis.paths.length === 1) {\n          geojson.type = 'LineString';\n          geojson.coordinates = arcgis.paths[0].slice(0);\n        } else {\n          geojson.type = 'MultiLineString';\n          geojson.coordinates = arcgis.paths.slice(0);\n        }\n      }\n\n      if (arcgis.rings) {\n        geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));\n      }\n\n      if (typeof arcgis.xmin === 'number' && typeof arcgis.ymin === 'number' && typeof arcgis.xmax === 'number' && typeof arcgis.ymax === 'number') {\n        geojson.type = 'Polygon';\n        geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];\n      }\n\n      if (arcgis.geometry || arcgis.attributes) {\n        geojson.type = 'Feature';\n        geojson.geometry = arcgis.geometry ? arcgisToGeoJSON(arcgis.geometry) : null;\n        geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;\n\n        if (arcgis.attributes) {\n          try {\n            geojson.id = getId(arcgis.attributes, idAttribute);\n          } catch (err) {// don't set an id\n          }\n        }\n      } // if no valid geometry was encountered\n\n\n      if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {\n        geojson.geometry = null;\n      }\n\n      if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {\n        console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));\n      }\n\n      return geojson;\n    })\n  }, {\n    key: \"geojsonToArcGIS\",\n    value: function (_geojsonToArcGIS) {\n      function geojsonToArcGIS(_x3, _x4) {\n        return _geojsonToArcGIS.apply(this, arguments);\n      }\n\n      geojsonToArcGIS.toString = function () {\n        return _geojsonToArcGIS.toString();\n      };\n\n      return geojsonToArcGIS;\n    }(function (geojson, idAttribute) {\n      idAttribute = idAttribute || 'OBJECTID';\n      var spatialReference = {\n        wkid: 4326\n      };\n      var result = {};\n      var i;\n      var geojson = geojson;\n\n      switch (geojson.type) {\n        case 'Point':\n          result.x = geojson.coordinates[0];\n          result.y = geojson.coordinates[1];\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'MultiPoint':\n          result.points = geojson.coordinates.slice(0);\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'LineString':\n          result.paths = [geojson.coordinates.slice(0)];\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'MultiLineString':\n          result.paths = geojson.coordinates.slice(0);\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'Polygon':\n          result.rings = orientRings(geojson.coordinates.slice(0));\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'MultiPolygon':\n          result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));\n          result.spatialReference = spatialReference;\n          break;\n\n        case 'Feature':\n          if (geojson.geometry && geojson.geometry.type != 'Polyline') {\n            result.geometry = this.geojsonToArcGIS(geojson.geometry, idAttribute);\n          }\n\n          if (geojson.properties) result.attributes = geojson.properties ? this.shallowClone(geojson.properties) : {}; //if (geojson.id)\n          //    result.attributes[idAttribute] = geojson.id;\n\n          break;\n\n        case 'FeatureCollection':\n          result = [];\n\n          for (i = 0; i < geojson.features.length; i++) {\n            result.push(this.geojsonToArcGIS(geojson.features[i], idAttribute));\n          }\n\n          break;\n\n        case 'GeometryCollection':\n          result = [];\n\n          for (i = 0; i < geojson.geometries.length; i++) {\n            result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));\n          }\n\n          break;\n      }\n\n      return result;\n    })\n  }, {\n    key: \"shallowClone\",\n    value: function shallowClone(obj) {\n      var target = {};\n\n      for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          target[i] = obj[i];\n        }\n      }\n\n      return target;\n    }\n  }]);\n\n  return Parse;\n}();\nmapboxgl.ekmap.Parse = Parse;\n\n//# sourceURL=webpack:///./src/mapboxgl/core/Parse.js?")},"./src/mapboxgl/core/Request.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ "./src/mapboxgl/core/Base.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar Request = /*#__PURE__*/function () {\n  function Request() {\n    _classCallCheck(this, Request);\n  }\n\n  _createClass(Request, [{\n    key: "get",\n\n    /** Phương thức GET\r\n     * @param {*} options\r\n     *  @param {string} options.url\r\n     *  @param {string} options.auth Xác thực nếu cần, dạng btoa("username:password");\r\n     *  @param {string} options.dataType Loại dữ liệu trả về, mặc định JSON\r\n     *  @param {string} options.success Hàm callback khi success\r\n     *  @param {string} options.error Hàm callback khi error\r\n     */\n    value: function get(options) {\n      var ajax = new gclient_ajax(options);\n      if (options.success) ajax.on(\'success\', function (e) {\n        options.success(e.response, e);\n      });\n      if (options.error) ajax.on(\'error\', function (e) {\n        options.error(e);\n      });\n      ajax.send(options.url, options.data, options.options);\n    }\n  }, {\n    key: "put",\n\n    /** Phương thức PUT\r\n     * @param {*} options\r\n     *  @param {string} options.url\r\n     *  @param {string} options.auth Xác thực nếu cần, dạng btoa("username:password");\r\n     *  @param {string} options.dataType Loại dữ liệu trả về, mặc định JSON\r\n     *  @param {string} options.data Dữ liệu PUT lên\r\n     *  @param {string} options.success Hàm callback khi success\r\n     *  @param {string} options.error Hàm callback khi error\r\n     */\n    value: function put(options) {\n      var ajax = new gclient_ajax(options);\n      if (options.success) ajax.on(\'success\', function (e) {\n        options.success(e.response, e);\n      });\n      if (options.error) ajax.on(\'error\', function (e) {\n        options.error(e);\n      });\n      ajax.send(options.url, options.data, options.options, "PUT");\n    }\n  }], [{\n    key: "send",\n    value: function send(url, data, options, callback) {\n      options = options || {};\n      var self = this; // Url\n\n      var encode = options.encode !== false;\n      if (encode) url = encodeURI(url); // New request\n\n      var ajax = new XMLHttpRequest();\n      ajax.open("GET", url, true);\n\n      if (options.header) {\n        for (var header in options.header) {\n          ajax.setRequestHeader(header, options.header[header]);\n        }\n      } // Load complete\n      //this.dispatchEvent({ type: \'loadstart\' });\n\n\n      ajax.onload = function () {\n        // self._request = null;\n        // self.dispatchEvent({ type: \'loadend\' });\n        if (this.status >= 200 && this.status < 400) {\n          var response; // Decode response\n\n          try {\n            response = JSON.parse(this.response);\n\n            if (response.features) {\n              callback(response.features);\n            }\n\n            if (response.results) {\n              callback(response.results);\n            }\n\n            if (response.layers) {\n              callback(response);\n            }\n\n            if (response.objectIdFieldName) {\n              callback(response);\n            }\n          } catch (e) {}\n        } else {}\n      }; // Oops\n\n\n      ajax.onerror = function () {}; // GO!\n\n\n      if (data) ajax.send(JSON.stringify(data));else ajax.send();\n    }\n  }, {\n    key: "post",\n\n    /** Phương thức POST\r\n     * @param {*} options\r\n     *  @param {string} options.url\r\n     *  @param {string} options.auth Xác thực nếu cần, dạng btoa("username:password");\r\n     *  @param {string} options.dataType Loại dữ liệu trả về, mặc định JSON\r\n     *  @param {string} options.data Dữ liệu POST lên\r\n     *  @param {string} options.success Hàm callback khi success\r\n     *  @param {string} options.error Hàm callback khi error\r\n     */\n    value: function post(url, data, options, callback) {\n      options = options || {};\n      var encode = options.encode !== false;\n      if (encode) url = encodeURI(url);\n\n      if (data.adds || data.updates || data.deletes) {\n        var dataPost = new FormData();\n        dataPost.append("f", "json");\n        dataPost.append("adds", data.adds);\n        dataPost.append("updates", data.updates);\n        dataPost.append("deletes", data.deletes);\n        if (options.token) dataPost.append("token", options.token);\n      } else {\n        if (isNaN(data % 2)) {\n          var dataPost = new FormData();\n          dataPost.append("f", "json");\n          dataPost.append("features", data);\n          if (options.token) dataPost.append("token", options.token);\n        } else {\n          var dataPost = new FormData();\n          dataPost.append("f", "json");\n          dataPost.append("objectIds", data);\n          if (options.token) dataPost.append("token", options.token);\n        }\n      }\n\n      var ajax = new XMLHttpRequest();\n      ajax.open("POST", url, false);\n\n      if (options.header) {\n        for (var header in options.header) {\n          ajax.setRequestHeader("Content-Type", options.header[header]);\n        }\n      } // Load complete\n\n\n      ajax.onload = function () {\n        // self._request = null;\n        // self.dispatchEvent({ type: \'loadend\' });\n        if (this.status >= 200 && this.status < 400) {\n          var response; // Decode response\n\n          try {\n            response = JSON.parse(this.response);\n            callback(response);\n          } catch (e) {}\n        } else {}\n      }; // Oops\n\n\n      ajax.onerror = function () {}; // GO!\n\n\n      if (dataPost) {\n        ajax.send(dataPost);\n      } else ajax.post();\n    }\n  }]);\n\n  return Request;\n}();\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.Request = Request;\n\n//# sourceURL=webpack:///./src/mapboxgl/core/Request.js?')},"./src/mapboxgl/core/Util.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Util\", function() { return Util; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ \"mapbox-gl\");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ \"./src/mapboxgl/core/Base.js\");\n/* harmony import */ var _core_Parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Parse */ \"./src/mapboxgl/core/Parse.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.Util\r\n * @category BaseType Util\r\n * @classdesc The tool class.\r\n */\n\nvar Util = /*#__PURE__*/function () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, null, [{\n    key: \"isNumber\",\n    value: function isNumber(value) {\n      if (value === \"\") {\n        return false;\n      }\n\n      var mdata = Number(value);\n\n      if (mdata === 0) {\n        return true;\n      }\n\n      return !isNaN(mdata);\n    }\n  }, {\n    key: \"isString\",\n    value: function isString(str) {\n      return typeof str === 'string' && str.constructor === String;\n    }\n  }, {\n    key: \"newGuid\",\n    value: function newGuid(attr) {\n      var len = attr || 32;\n      var guid = \"\";\n\n      for (var i = 1; i < len; i++) {\n        var n = Math.floor(Math.random() * 16.0).toString(16);\n        guid += n;\n      }\n\n      return guid;\n    }\n  }, {\n    key: \"hexToRgba\",\n    value: function hexToRgba(hex, opacity) {\n      var color = [],\n          rgba = [];\n      hex = hex.replace(/#/, \"\");\n\n      if (hex.length == 3) {\n        var tmp = [];\n\n        for (var i = 0; i < 3; i++) {\n          tmp.push(hex.charAt(i) + hex.charAt(i));\n        }\n\n        hex = tmp.join(\"\");\n      }\n\n      for (var _i = 0; _i < 6; _i += 2) {\n        color[_i] = \"0x\" + hex.substr(_i, 2);\n        rgba.push(parseInt(Number(color[_i])));\n      }\n\n      rgba.push(opacity);\n      return \"rgba(\" + rgba.join(\",\") + \")\";\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(fn, obj) {\n      var slice = Array.prototype.slice;\n\n      if (fn.bind) {\n        return fn.bind.apply(fn, slice.call(arguments, 1));\n      }\n\n      var args = slice.call(arguments, 2);\n      return function () {\n        return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(params) {\n      var data = '';\n      var i = 0;\n      params.f = params.f || 'json';\n\n      for (var key in params) {\n        i++;\n\n        if (params.hasOwnProperty(key)) {\n          var param = params[key];\n          var type = Object.prototype.toString.call(param);\n          var value;\n\n          if (data.length) {\n            data += '&';\n          }\n\n          if (type === '[object Array]') {\n            value = Object.prototype.toString.call(param[0]) === '[object Object]' ? JSON.stringify(param) : param.join(',');\n          } else if (type === '[object Object]') {\n            value = JSON.stringify(param);\n          } else if (type === '[object Date]') {\n            value = param.valueOf();\n          } else {\n            value = param;\n          }\n\n          data += encodeURIComponent(key) + '=' + value;\n        }\n      }\n\n      return data;\n    }\n  }, {\n    key: \"_setGeometry\",\n    value: function _setGeometry(geometry) {\n      var params = {\n        geometry: null,\n        geometryType: null\n      };\n\n      if (geometry instanceof mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.LngLat) {\n        geometry = {\n          type: 'Point',\n          coordinates: [geometry.lng, geometry.lat]\n        };\n      }\n\n      if (geometry instanceof mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.LngLatBounds) {\n        // set geometry + geometryType\n        params.geometry = this.boundsToExtent(geometry);\n        params.geometryType = 'esriGeometryEnvelope';\n        return params;\n      } // confirm that our GeoJSON is a point, line or polygon\n\n\n      if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\n        params.geometry = _core_Parse__WEBPACK_IMPORTED_MODULE_2__[\"Parse\"].geojsonToArcGIS(geometry);\n        params.geometryType = this.geojsonTypeToArcGIS(geometry.type);\n        return params;\n      } // convert L.Marker > L.LatLng\n\n\n      if (geometry.getLatLng) {\n        geometry = geometry.getLatLng();\n      } // handle L.GeoJSON, pull out the first geometry\n      //if (geometry instanceof GeoJSON) {\n      //    // reassign geometry to the GeoJSON value  (we are assuming that only one feature is present)\n      //    geometry = geometry.getLayers()[0].feature.geometry;\n      //    params.geometry = geojsonToArcGIS(geometry);\n      //    params.geometryType = geojsonTypeToArcGIS(geometry.type);\n      //}\n      // Handle L.Polyline and L.Polygon\n      //if (geometry.toGeoJSON) {\n      //    geometry = geometry.toGeoJSON();\n      //}\n      // handle GeoJSON feature by pulling out the geometry\n\n\n      if (geometry.type === 'Feature') {\n        // get the geometry of the geojson feature\n        geometry = geometry.geometry;\n      }\n    }\n  }, {\n    key: \"boundsToExtent\",\n    value: function boundsToExtent(bounds) {\n      return {\n        'xmin': bounds.getSouthWest().lng,\n        'ymin': bounds.getSouthWest().lat,\n        'xmax': bounds.getNorthEast().lng,\n        'ymax': bounds.getNorthEast().lat,\n        'spatialReference': {\n          'wkid': 4326\n        }\n      };\n    }\n  }, {\n    key: \"geojsonTypeToArcGIS\",\n    value: function geojsonTypeToArcGIS(geoJsonType) {\n      var arcgisGeometryType;\n\n      switch (geoJsonType) {\n        case 'Point':\n          arcgisGeometryType = 'esriGeometryPoint';\n          break;\n\n        case 'MultiPoint':\n          arcgisGeometryType = 'esriGeometryMultipoint';\n          break;\n\n        case 'LineString':\n          arcgisGeometryType = 'esriGeometryPolyline';\n          break;\n\n        case 'MultiLineString':\n          arcgisGeometryType = 'esriGeometryPolyline';\n          break;\n\n        case 'Polygon':\n          arcgisGeometryType = 'esriGeometryPolygon';\n          break;\n\n        case 'MultiPolygon':\n          arcgisGeometryType = 'esriGeometryPolygon';\n          break;\n      }\n\n      return arcgisGeometryType;\n    }\n  }, {\n    key: \"isArray\",\n    value: function isArray(obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(obj, options) {\n      if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {\n        obj.options = obj.options ? create(obj.options) : {};\n      }\n\n      for (var i in options) {\n        obj.options[i] = options[i];\n      }\n\n      return obj.options;\n    }\n  }, {\n    key: \"getUrlParams\",\n    value: function getUrlParams(options) {\n      if (options.url.indexOf('?') !== -1) {\n        options.requestParams = options.requestParams || {};\n        var queryString = options.url.substring(options.url.indexOf('?') + 1);\n        options.url = options.url.split('?')[0];\n        options.requestParams = JSON.parse('{\"' + decodeURI(queryString).replace(/\"/g, '\\\\\"').replace(/&/g, '\",\"').replace(/=/g, '\":\"') + '\"}');\n      }\n\n      options.url = this.cleanUrl(options.url.split('?')[0]);\n      return options;\n    }\n  }, {\n    key: \"getUrl\",\n    value: function getUrl(options) {\n      if (options.url.indexOf('/0') != '-1') option.url = options.url.split('/0').join('');\n      if (options.url.indexOf('/1') != '-1') option.url = options.url.split('/1').join('');\n      if (options.url.indexOf('/2') != '-1') option.url = options.url.split('/2').join('');\n      if (options.url.indexOf('/3') != '-1') option.url = options.url.split('/3').join('');\n      return options;\n    }\n  }, {\n    key: \"getUrlsParams\",\n    value: function getUrlsParams(options) {\n      var string = options.urls.split(\".\")[0];\n      var indexCut = string.indexOf(\"{\") - 1;\n      var stringCut = string.split(string[indexCut])[2];\n      var urls = [];\n\n      for (var i = stringCut[1]; i <= stringCut[3]; i++) {\n        urls.push(options.urls.split(stringCut).join(i));\n      }\n\n      options.urls = urls;\n      return options;\n    }\n  }, {\n    key: \"cleanUrl\",\n    value: function cleanUrl(url) {\n      // trim leading and trailing spaces, but not spaces inside the url\n      // add a trailing slash to the url if the user omitted it\n      if (url[url.length - 1] !== '/') {\n        url += '/';\n      }\n\n      return url;\n    }\n  }, {\n    key: \"splitWords\",\n    value: function splitWords(str) {\n      return this.trim(str).split(/\\s+/);\n    }\n  }, {\n    key: \"trim\",\n    value: function trim(str) {\n      return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n    } // @function stamp(obj: Object): Number\n    // Returns the unique ID of an object, assigning it one if it doesn't have it.\n\n  }, {\n    key: \"stamp\",\n    value: function stamp(obj) {\n      /*eslint-disable */\n      var lastId = 0;\n      obj._leaflet_id = obj._leaflet_id || ++lastId;\n      return obj._leaflet_id;\n      /* eslint-enable */\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(fn, obj) {\n      var slice = Array.prototype.slice;\n\n      if (fn.bind) {\n        return fn.bind.apply(fn, slice.call(arguments, 1));\n      }\n\n      var args = slice.call(arguments, 2);\n      return function () {\n        return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);\n      };\n    }\n  }, {\n    key: \"cancelAnimFrame\",\n    value: function cancelAnimFrame(id) {\n      var cancelFn = window.cancelAnimationFrame || this.getPrefixed('CancelAnimationFrame') || this.getPrefixed('CancelRequestAnimationFrame') || function (id) {\n        window.clearTimeout(id);\n      };\n\n      if (id) {\n        cancelFn.call(window, id);\n      }\n    }\n  }, {\n    key: \"getPrefixed\",\n    value: function getPrefixed(name) {\n      return window['webkit' + name] || window['moz' + name] || window['ms' + name];\n    }\n  }, {\n    key: \"formatNum\",\n    value: function formatNum(num, digits) {\n      var pow = Math.pow(10, digits === undefined ? 6 : digits);\n      return Math.round(num * pow) / pow;\n    }\n  }, {\n    key: \"extend\",\n    value: function extend(dest) {\n      var i, j, len, src;\n\n      for (j = 1, len = arguments.length; j < len; j++) {\n        src = arguments[j];\n\n        for (i in src) {\n          dest[i] = src[i];\n        }\n      }\n\n      return dest;\n    }\n  }, {\n    key: \"deepClone\",\n    value: function deepClone(obj) {\n      var _this = this;\n\n      var cloned = {};\n      if (_typeof(obj) !== 'object') return obj;\n      if (obj instanceof Array) return obj.map(function (ele) {\n        return _this.deepClone(ele);\n      });\n\n      for (var k in obj) {\n        if (obj.hasOwnProperty(k) && _typeof(obj[k]) !== 'object') {\n          cloned[k] = obj[k];\n        } else if (obj[k].constructor.toString().indexOf(\"Object\") > 0) {\n          cloned[k] = this.deepClone(obj[k]);\n        } else if (Array.isArray(obj[k])) {\n          cloned[k] = obj[k].map(function (ele) {\n            // let ret = null;\n            if (_typeof(ele) !== 'object') return ele;else return _this.deepClone(ele);\n          }); // cloned[k] = [].concat(obj[k]);\n        }\n      }\n\n      return cloned;\n    }\n    /**\r\n     * @private\r\n     * @description add img, video element to domContainer.\r\n     * @param {Array} dom dom container..\r\n     * @param {Array} res urls of img/video loaded to dom. \r\n     */\n\n  }, {\n    key: \"setResource\",\n    value: function setResource(dom, res) {\n      if (!(res instanceof Array)) return;\n      dom.innerHTML = '';\n\n      for (var i = 0; i < res.length; i++) {\n        var filetype = this.getFiletype(res[i]);\n\n        if (filetype !== \"\") {\n          var _ele = document.createElement(filetype);\n\n          _ele.style.width = _ele.style.height = dom.style.width = dom.style.height = '60px';\n          _ele.style.borderRadius = \"50%\";\n          _ele.src = res[i];\n          dom.style.borderRadius = \"50%\";\n          dom.appendChild(_ele);\n        }\n\n        if (filetype == 'video') {\n          ele.setAttribute('autoplay', true);\n        }\n      }\n    }\n    /**\r\n     * return iconposition style by iconName\r\n     */\n\n  }, {\n    key: \"setIconDiv\",\n    value: function setIconDiv(dom, iconName) {\n      var icons = Const.Sprites;\n\n      if (iconName && icons[iconName]) {\n        var iconStyle = icons[iconName],\n            iconDiv = document.createElement(\"div\");\n        iconDiv.style.width = iconStyle.width + \"px\";\n        iconDiv.style.height = iconStyle.height + \"px\";\n        iconDiv.style.overflow = 'hidden';\n        var iconImg = document.createElement(\"img\");\n        iconImg.src = Const.SpritesUrl + \".png\";\n        iconImg.style.marginLeft = \"-\" + iconStyle.x + \"px\";\n        iconImg.style.marginTop = \"-\" + iconStyle.y + \"px\";\n        iconDiv.appendChild(iconImg);\n        dom.appendChild(iconDiv);\n      }\n    }\n  }, {\n    key: \"isChanged\",\n    value: function isChanged(lastData, data) {\n      if (JSON.stringify(lastData) == JSON.stringify(data)) return false;else {\n        return true;\n      }\n    }\n  }, {\n    key: \"setChart\",\n    value: function setChart(dom, data, type, height) {\n      if (!Chart) {\n        return;\n      }\n\n      var canv = document.createElement('canvas'),\n          ctx = canv.getContext('2d');\n      if (type == 'bar') canv.style.backgroundColor = 'rgb(245, 222, 179)';else canv.style.backgroundColor = 'rgba(0,0,0,0.0)';\n      var chart = new Chart(ctx, {\n        type: type,\n        data: data,\n        options: {\n          legend: {\n            display: false\n          } // title: {\n          //     display: true,\n          //     fontColor: 'red',\n          //     fontSize: 15,\n          //     text: 'Custom Chart Title'\n          // }\n\n        }\n      });\n      canv.height = height;\n      canv.style.height = canv.height + 'px';\n      canv.width = height;\n      canv.style.width = canv.width + 'px';\n      dom.appendChild(canv);\n      return chart;\n    }\n  }]);\n\n  return Util;\n}();\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.Util = Util;\n\n//# sourceURL=webpack:///./src/mapboxgl/core/Util.js?")},"./src/mapboxgl/core/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Util */ "./src/mapboxgl/core/Util.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Util", function() { return _Util__WEBPACK_IMPORTED_MODULE_0__["Util"]; });\n\n/* harmony import */ var _Parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Parse */ "./src/mapboxgl/core/Parse.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Parse", function() { return _Parse__WEBPACK_IMPORTED_MODULE_1__["Parse"]; });\n\n\n\n\n//# sourceURL=webpack:///./src/mapboxgl/core/index.js?')},"./src/mapboxgl/css/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ "./src/mapboxgl/css/style.css");\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_0__);\n\n\n//# sourceURL=webpack:///./src/mapboxgl/css/index.js?')},"./src/mapboxgl/css/style.css":function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./src/mapboxgl/css/style.css?")},"./src/mapboxgl/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./control */ "./src/mapboxgl/control/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SnapShot", function() { return _control__WEBPACK_IMPORTED_MODULE_0__["SnapShot"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Swipe", function() { return _control__WEBPACK_IMPORTED_MODULE_0__["Swipe"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FeatureInfomation", function() { return _control__WEBPACK_IMPORTED_MODULE_0__["FeatureInfomation"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Legend", function() { return _control__WEBPACK_IMPORTED_MODULE_0__["Legend"]; });\n\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ "./src/mapboxgl/core/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Util", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Util"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Parse", function() { return _core__WEBPACK_IMPORTED_MODULE_1__["Parse"]; });\n\n/* harmony import */ var _layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layer */ "./src/mapboxgl/layer/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HeatMapLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["HeatMapLayer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledMapLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["TiledMapLayer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VectorTiledMapLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["VectorTiledMapLayer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledRoadMapLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["TiledRoadMapLayer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledAdminMapLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["TiledAdminMapLayer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledOSMapLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["TiledOSMapLayer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FeatureLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["FeatureLayer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ThreeLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["ThreeLayer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DomOverlay", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["DomOverlay"]; });\n\n/* harmony import */ var _services__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./services */ "./src/mapboxgl/services/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FeatureService", function() { return _services__WEBPACK_IMPORTED_MODULE_3__["FeatureService"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MapService", function() { return _services__WEBPACK_IMPORTED_MODULE_3__["MapService"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ServiceBase", function() { return _services__WEBPACK_IMPORTED_MODULE_3__["ServiceBase"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IdentifyFeatures", function() { return _services__WEBPACK_IMPORTED_MODULE_3__["IdentifyFeatures"]; });\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/mapboxgl/index.js?')},"./src/mapboxgl/layer/DomOverlay.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DomOverlay", function() { return DomOverlay; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Util */ "./src/mapboxgl/core/Util.js");\n/* harmony import */ var _Overlay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Overlay */ "./src/mapboxgl/layer/Overlay.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n/**\n * @class mapboxgl.ekmap.DomOverlay\n * @classdesc mapboxgl.ekmap.DomOverlay \n * @category Layer\n * @param {Object} options - Construction parameters.\n * @param {mapboxgl.Map} options.map Adds the layer to the given map or layer group.\n * @param {Array.<GeoJSONObject>} options.features List features.\n * @param {string} options.type Type of Chart.\n * @param {Array.<string>} options.fields List fields display and fields properties data.\n * @param {Array.<string>} options.colors Color corresponds to the data. \n * \n * @extends {mapboxgl.Overlay}\n */\n\nvar DomOverlay = /*#__PURE__*/function (_Overlay) {\n  _inherits(DomOverlay, _Overlay);\n\n  var _super = _createSuper(DomOverlay);\n\n  function DomOverlay(opts) {\n    var _this;\n\n    _classCallCheck(this, DomOverlay);\n\n    _this = _super.call(this, opts);\n    _this.domContainer = _this._init();\n    _this.redraw = _redraw.bind(_assertThisInitialized(_this));\n    _this.features = opts.features;\n    _this.fields = opts.fields;\n    _this.domOpts = [];\n\n    _this.features.forEach(function (fea) {\n      var data = [];\n\n      _this.fields.forEach(function (field) {\n        data.push(fea.properties[field]);\n      });\n\n      _this.domOpts.push({\n        type: opts.type,\n        data: {\n          datasets: [{\n            data: data,\n            backgroundColor: opts.colors,\n            datalabels: {\n              color: \'#FFCE56\'\n            }\n          }],\n          labels: _this.fields\n        },\n        lon: fea.geometry.coordinates[0],\n        lat: fea.geometry.coordinates[1]\n      });\n    });\n\n    if (opts && opts.map) {\n      _Overlay__WEBPACK_IMPORTED_MODULE_2__["default"].setMap(opts.map); // bind render doms to each move..performance to be promoted.\n\n      opts.map.on("move", _this.redraw);\n    }\n\n    _this.doms = []; // store dom elements.\n\n    _this.lastData = [];\n\n    _this.redraw();\n\n    return _this;\n  }\n\n  _createClass(DomOverlay, [{\n    key: "_init",\n    value: function _init() {\n      var canvasContainer = this.map._canvasContainer,\n          mapboxCanvas = this.map._canvas,\n          domContainer = document.createElement("div");\n      domContainer.style.position = "absolute";\n      domContainer.className = "overlay-dom";\n      domContainer.style.width = mapboxCanvas.style.width;\n      domContainer.style.height = \'0\';\n      canvasContainer.parentElement.appendChild(domContainer);\n      return domContainer;\n    }\n    /**\n     * @function mapboxgl.ekmap.DomOverlay.prototype.setDoms\n     * @description updateDoms and redraw.\n     * @param {Object} Doms\n     */\n\n  }, {\n    key: "setDoms",\n    value: function setDoms(Doms) {\n      if (Array.isArray(Doms)) {\n        this.domOpts = Doms;\n        this.clearDoms();\n        this.redraw();\n      }\n    }\n    /**\n     * @function mapboxgl.ekmap.DomOverlay.prototype.findDom\n     * @param {string} domId\n     */\n\n  }, {\n    key: "findDom",\n    value: function findDom(domId) {\n      for (var i = 0; i < this.doms.length; i++) {\n        try {\n          if (this.doms[i] === domId) {\n            return this.doms[i];\n          }\n        } catch (error) {}\n      }\n    }\n    /**\n     * @function mapboxgl.ekmap.DomOverlay.prototype.clearDoms\n     * @description remove all doms.\n     */\n\n  }, {\n    key: "clearDoms",\n    value: function clearDoms() {\n      for (var i = 0; i < this.doms.length; i++) {\n        this.domContainer.removeChild(this.doms[i]);\n      }\n\n      this.doms = [];\n    }\n  }]);\n\n  return DomOverlay;\n}(_Overlay__WEBPACK_IMPORTED_MODULE_2__["default"]);\nvar lineHeight = 60,\n    dotRadius = 4,\n    chartHeight = 80;\n/**\n * domOverlay register&render above default canvas..\n * keep in absolute geolocation..\n */\n\nfunction _redraw() {\n  var doms = this.domOpts;\n\n  if (doms && Array.isArray(doms)) {\n    // append each of domPopups to domContainer.\n    for (var i = 0; i < doms.length; i++) {\n      var domOpt = doms[i];\n      if (_typeof(domOpt) == undefined) continue; // let sanity = Util.checkSanity(this.lastDoms[i], domOpt);\n\n      var x = domOpt[\'lon\'],\n          y = domOpt[\'lat\'],\n          pix = this.lnglat2pix(x, y);\n      if (pix == null) continue;\n      var iconName = domOpt[\'icon\'],\n          resources = domOpt[\'resources\'],\n          domStyle = domOpt[\'style\'] ? domOpt[\'style\'] + \' animated\' : \'bounceInRight animated\',\n          chartData = domOpt[\'data\'],\n          chartType = domOpt[\'type\']; // data sanity should be checked, domOpts not changed then just update position!\n\n      var dom = this.doms[i * 3] || document.createElement("div"),\n          line = this.doms[i * 3 + 1] || document.createElement("div"),\n          dot = this.doms[i * 3 + 2] || document.createElement("div");\n      preStyleEles(line, dot, dom, pix, chartType || resources);\n      var dataClone = _core_Util__WEBPACK_IMPORTED_MODULE_1__["Util"].deepClone(chartData); // handle different typesof domOverlay.\n\n      if (resources != undefined) {\n        dom.title = domOpt[\'content\'] || "";\n\n        if (!dom.hasChildNodes() || dom.firstChild.src !== resources[0]) {\n          _core_Util__WEBPACK_IMPORTED_MODULE_1__["Util"].setResource(dom, resources);\n        }\n      } else if (iconName != undefined) {\n        dom.innerHTML = (domOpt[\'content\'] || "") + \'</br>\';\n        _core_Util__WEBPACK_IMPORTED_MODULE_1__["Util"].setIconDiv(dom, iconName);\n      } else if (chartData != undefined && chartType != undefined) {\n        if (_core_Util__WEBPACK_IMPORTED_MODULE_1__["Util"].isChanged(this.lastData[i], chartData)) {\n          // setChart would contaminate input Data.\n          _core_Util__WEBPACK_IMPORTED_MODULE_1__["Util"].setChart(dom, dataClone, chartType, chartHeight * 2);\n          this.lastData[i] = chartData;\n        }\n      } else {\n        dom.innerHTML = (domOpt[\'content\'] || \'\') + \'</br>\';\n      }\n\n      if (chartType != undefined) styleChartContainer(dom);\n      line.className = "dom-ele", dot.className = "dom-ele";\n      line.style.left = pix[0] + "px";\n      line.style.top = pix[1] - (lineHeight - 10) + "px";\n      dot.style.left = pix[0] - dotRadius + "px";\n      dot.style.top = pix[1] - dotRadius + "px"; // add dom to container at init process.\n\n      if (this.doms[i * 3] == undefined) {\n        var _this$doms;\n\n        dom.className = "dom-popup ".concat(domStyle);\n        line.className = dot.className = "dom-ele ".concat(domStyle);\n        this.domContainer.appendChild(dom);\n        this.domContainer.appendChild(line);\n        this.domContainer.appendChild(dot);\n\n        (_this$doms = this.doms).push.apply(_this$doms, [dom, line, dot]);\n      }\n    }\n  }\n}\n/**\n *  ___________\n * |chart/img  |   main popup. /// It is key topic to place popup align.\n *  -----------\n *       |         line/triangle.. (should implement by psuedoClass!)\n *       。         point..\n * chartWidth always 2*chartHeight if using Chart.js\n */\n\n\nfunction preStyleEles(line, dot, dom, pix, chartType) {\n  var isImg = Array.isArray(chartType);\n  line.style.height = lineHeight - 10 + \'px\';\n  line.style.width = \'1px\';\n  line.style.position = "absolute";\n  dot.style.borderRadius = \'50%\';\n  dot.style.width = dot.style.height = dotRadius * 2 + \'px\';\n  dot.style.position = "absolute";\n  dom.style.position = "absolute";\n\n  if (!chartType) {\n    dom.style.minWidth = "100px"; // consistant with chart/image dom width/height.\n  } // dom.style.background = "#fff";\n\n\n  dom.style.textAlign = "center";\n  dom.style.padding = \'3px\'; // if has chartType, display chart above vertical line.\n\n  dom.style.left = pix[0] - 166 / 2 + "px";\n  dom.style.top = pix[1] - 86 / 2 + "px";\n}\n\nfunction styleChartContainer(dom) {\n  dom.style.borderWidth = \'0\';\n  dom.style.zIndex = 9999; // dom.style.backgroundColor = \'rgba(0,0,0,0.0)\';\n}\n\nfunction animLine(line) {\n  line.className = "dom-line";\n}\n\nvar htmlTemplate = {};\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.DomOverlay = DomOverlay;\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/DomOverlay.js?')},"./src/mapboxgl/layer/FeatureLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FeatureLayer\", function() { return FeatureLayer; });\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Util */ \"./src/mapboxgl/core/Util.js\");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mapbox-gl */ \"mapbox-gl\");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/**\r\n * @class mapboxgl.ekmap.FeatureLayer\r\n * @classdesc mapboxgl.ekmap.FeatureLayer is used to visualize, style, query and edit vector geographic data hosted in both ArcGIS Online and published using ArcGIS Server. Copyright text from the service is added to map attribution automatically.\r\n * @category  Layer\r\n * @param {Object} options - Construction parameters.\r\n * @param {string} options.url - Required The URL to the {@link https://developers.arcgis.com/rest/services-reference/layer-feature-service-.htm|Feature Layer}.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n * @extends {mapboxgl.Evented}\r\n * @fires mapboxgl.ekmap.FeatureLayer#loadstart\r\n * @fires mapboxgl.ekmap.FeatureLayer#loadend\r\n */\n\nvar FeatureLayer = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(FeatureLayer, _mapboxgl$Evented);\n\n  var _super = _createSuper(FeatureLayer);\n\n  function FeatureLayer(options) {\n    var _this;\n\n    _classCallCheck(this, FeatureLayer);\n\n    _this = _super.call(this);\n    _this.options = options ? options : {};\n\n    if (options) {\n      options = _core_Util__WEBPACK_IMPORTED_MODULE_0__[\"Util\"].setOptions(_assertThisInitialized(_this), options); // set the urls\n\n      if (options.url) {\n        options = _core_Util__WEBPACK_IMPORTED_MODULE_0__[\"Util\"].getUrlParams(options);\n        if (options.url.indexOf('{s}') !== -1 && options.subdomains && options.url) options.url = options.url.replace('{s}', options.subdomains[0]);\n        _this.service = new mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.FeatureService(options);\n      }\n\n      if (_this.options.token) {\n        _this.tileUrl += '?token=' + _this.options.token;\n      }\n    }\n\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.FeatureLayer.prototype.addTo\r\n   * @description Adds the layer to the given map or layer group.\r\n   * @param {mapboxgl.Map} map Adds the layer to the given map or layer group.\r\n   * @returns {this}\r\n   */\n\n\n  _createClass(FeatureLayer, [{\n    key: \"addTo\",\n    value: function addTo(map) {\n      this.map = map;\n      var params = {\n        where: '1=1'\n      };\n      var me = this;\n      /**\r\n       * @event mapboxgl.ekmap.FeatureLayer#loadstart\r\n       * @description Fired when the feature layer load start.\r\n       */\n\n      me.fire('loadstart', me);\n      this.service.query(params, function (result) {\n        if (result[0].geometry.type == \"Point\") {\n          map.addSource('point', {\n            \"type\": \"geojson\",\n            \"data\": {\n              'type': 'FeatureCollection',\n              'features': result\n            }\n          });\n          map.addLayer({\n            \"id\": \"point\",\n            \"type\": \"circle\",\n            \"paint\": {\n              \"circle-radius\": 10,\n              \"circle-color\": \"red\"\n            },\n            \"source\": 'point'\n          });\n          map.addLayer({\n            \"id\": \"point-selected\",\n            \"type\": \"circle\",\n            \"paint\": {\n              \"circle-radius\": 10,\n              \"circle-color\": \"red\",\n              \"circle-stroke-color\": '#00ffff',\n              \"circle-stroke-width\": 3\n            },\n            'filter': ['in', 'OBJECTID', ''],\n            \"source\": 'point'\n          });\n        }\n\n        if (result[0].geometry.type == \"LineString\") {\n          map.addSource('line', {\n            \"type\": \"geojson\",\n            \"data\": {\n              'type': 'FeatureCollection',\n              'features': result\n            }\n          });\n          map.addLayer({\n            'id': \"line\",\n            'type': 'line',\n            'layout': {\n              'line-join': 'round',\n              'line-cap': 'round'\n            },\n            'paint': {\n              'line-color': '#000',\n              'line-width': 5\n            },\n            \"source\": \"line\"\n          });\n          map.addLayer({\n            'id': \"line-selected\",\n            'type': 'line',\n            'layout': {\n              'line-join': 'round',\n              'line-cap': 'round'\n            },\n            'paint': {\n              'line-color': 'blue',\n              'line-width': 5\n            },\n            'filter': ['in', 'OBJECTID', ''],\n            \"source\": \"line\"\n          });\n        }\n\n        if (result[0].geometry.type == \"LineString\") {\n          map.addSource('area', {\n            \"type\": \"geojson\",\n            lineMetrics: true,\n            'data': {\n              'type': 'Feature',\n              'geometry': {\n                'type': 'LineString',\n                'coordinates': result\n              }\n            }\n          });\n          map.addLayer({\n            'id': 'area',\n            'type': 'line',\n            'layout': {\n              'line-join': 'round',\n              'line-cap': 'round'\n            },\n            'paint': {\n              'line-color': '#90c258',\n              'line-width': 5,\n              'line-gradient': ['interpolate', ['linear'], ['line-progress'], 0, 'blue', 0.1, 'royalblue', 0.3, 'cyan', 0.5, 'lime', 0.7, 'yellow', 1, 'red']\n            },\n            'source': 'area'\n          });\n          map.addLayer({\n            'id': 'area-selected',\n            'type': 'line',\n            'layout': {\n              'line-join': 'round',\n              'line-cap': 'round'\n            },\n            'paint': {\n              'line-color': 'white',\n              'line-width': 5\n            },\n            'filter': ['in', 'OBJECTID', ''],\n            \"source\": 'area'\n          });\n        }\n        /**\r\n        * @event mapboxgl.ekmap.FeatureLayer#loadend\r\n        * @description Fired when the feature layer load end. \r\n        */\n\n\n        me.fire('loadend', me);\n      });\n      return this;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.FeatureLayer.prototype.query\r\n     * @description Query data.\r\n     * @param {Object} params - Adds the layer to the given map or layer group.\r\n     * @param {RequestCallback} callback \r\n     *\r\n     */\n\n  }, {\n    key: \"query\",\n    value: function query(params, callback, context) {\n      return this.service.query(params, callback, context);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.FeatureLayer.prototype.queryByBound\r\n     * @description  is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.\r\n     * @param {mapboxgl.LngLatBounds} lngLatBounds\r\n     * @param {RequestCallback} callback\r\n     */\n\n  }, {\n    key: \"queryByBound\",\n    value: function queryByBound(params, callback, context) {\n      return this.service.queryByBound(params, callback, context);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.FeatureLayer.prototype.queryByGeometry\r\n     * @description  is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.\r\n     * @param {string} geometry The geometry to apply as the spatial filter. The structure of the geometry is the same as the structure of the JSON geometry objects returned by the ArcGIS REST API. In addition to the JSON structures, for envelopes and points, you can specify the geometry with a simpler comma-separated syntax.\r\n     * @param {RequestCallback} callback\r\n     */\n\n  }, {\n    key: \"queryByGeometry\",\n    value: function queryByGeometry(params, callback, context) {\n      return this.service.queryByGeometry(params, callback, context);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.FeatureLayer.prototype.addFeature\r\n     * @description Adds a new feature to the feature layer. this also adds the feature to the map if creation is successful.\r\n     * @param {GeoJSONObject} params GeoJSON of feature add (To change point color, set 'color' for options GeoJSON, the default is light blue ('#3FB1CE')).\r\n     * @param {Function} callback\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: \"addFeature\",\n    value: function addFeature(params, callback, context) {\n      var coor = params.geometry.coordinates;\n      var marker = new mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.Marker({\n        'color': params.color ? params.color : ''\n      }).setLngLat(coor).addTo(this.map);\n      this.addFeatures(params, callback, context);\n    }\n    /**\r\n     * @private\r\n     * @function mapboxgl.ekmap.FeatureLayer.prototype.addFeatures\r\n     * @description Adds a new feature to the feature layer. this also adds the feature to the map if creation is successful.\r\n     * @param {GeoJSONObject} params GeoJSON of feature add (To change point color, set 'color' for options GeoJSON, the default is light blue ('#3FB1CE')).\r\n     * @param {Function} callback\r\n     * @param {Object} context\r\n     * @returns {this}\r\n    */\n\n  }, {\n    key: \"addFeatures\",\n    value: function addFeatures(params, callback, context) {\n      return this.service.addFeatures(params, callback, context);\n    }\n    /**\r\n    * @function mapboxgl.ekmap.FeatureLayer.prototype.updateFeature\r\n    * @description Update the provided feature on the Feature Layer. This also updates the feature on the map. To update the point location on the map. Please use function {@link mapboxgl.ekmap.FeatureLayer.html#refresh|refresh()} then update.\r\n    * @param {GeoJSONObject} feature Infomation feature by geoJSON.\r\n    * @param {Function} callback The callback of result data returned by the server side.\r\n    * @param {Object} context\r\n    * @returns {this}\r\n    */\n\n  }, {\n    key: \"updateFeature\",\n    value: function updateFeature(feature, callback, context) {\n      this.updateFeatures(feature, callback, context);\n    }\n    /**\r\n    * @private\r\n    * @function mapboxgl.ekmap.FeatureLayer.prototype.updateFeatures\r\n    * @description Update the provided feature on the Feature Layer. This also updates the feature on the map.\r\n    * @param {GeoJSONObject} geojson Infomation feature by geoJSON.\r\n    * @param {Function} callback The callback of result data returned by the server side.\r\n    * @param {Object} context\r\n    */\n\n  }, {\n    key: \"updateFeatures\",\n    value: function updateFeatures(geojson, callback, context) {\n      return this.service.updateFeatures(geojson, callback, context);\n    }\n    /**\r\n    * @function mapboxgl.ekmap.FeatureLayer.prototype.deleteFeature\r\n    * @description Remove the feature with the provided id from the feature layer. This will also remove the feature from the map if it exists. Please use function {@link mapboxgl.ekmap.FeatureLayer.html#refresh|refresh()} then delete.\r\n    * @param {Interger} id Id of feature.\r\n    * @param {Function} callback The callback of result data returned by the server side.\r\n    * @param {Object} context\r\n    * @returns {this}\r\n    */\n\n  }, {\n    key: \"deleteFeature\",\n    value: function deleteFeature(id, callback, context) {\n      this.deleteFeatures(id, callback, context);\n    }\n    /**\r\n    * @private\r\n    * @function mapboxgl.ekmap.FeatureLayer.prototype.deleteFeatures\r\n    * @description Removes an array of features with the provided ids from the feature layer. This will also remove the features from the map if they exist.\r\n    * @param {Interger} ids List id of features.\r\n    * @param {Function} callback The callback of result data returned by the server side.\r\n    * @param {Object} context\r\n    * @returns {this}\r\n    */\n\n  }, {\n    key: \"deleteFeatures\",\n    value: function deleteFeatures(ids, callback, context) {\n      return this.service.deleteFeatures(ids, callback, context);\n    }\n    /**\r\n    * @function mapboxgl.ekmap.FeatureLayer.prototype.refresh\r\n    * @description Redraws all features from the feature layer that exist on the map.\r\n    */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var me = this;\n      var data = {};\n      var params = {\n        where: '1=1'\n      };\n      this.service.query(params, function (result) {\n        data = {\n          'type': 'FeatureCollection',\n          'features': result\n        };\n        var filter = [\"in\", \"OBJECTID\"];\n\n        if (me.map.getLayer('point')) {\n          me.map.getSource('point').setData(data);\n          map.setFilter('point-selected', filter);\n        }\n\n        if (me.map.getLayer('line')) {\n          map.setFilter('line-selected', filter);\n          me.map.getSource('line').setData(data);\n        }\n\n        if (me.map.getLayer('area')) {\n          me.map.getSource('area').setData(data);\n          map.setFilter('area-selected', filter);\n        }\n      });\n    }\n    /**\r\n    * @function mapboxgl.ekmap.FeatureLayer.prototype.applyEdits\r\n    * @description This operation adds, updates, and deletes features to the associated feature layer. Please use function {@link mapboxgl.ekmap.FeatureLayer.html#refresh|refresh()} then applyEdits.\r\n    * @param {Object} params Options.\r\n    * @param {GeoJSONObject} params.adds GeoJSON of feature add (To change point color, set 'color' for options GeoJSON).\r\n    * @param {GeoJSONObject} params.updates GeoJSON of feature update.\r\n    * @param {Interger} params.deletes Id of feature delete.\r\n    * @param {RequestCallback} callback\r\n    */\n\n  }, {\n    key: \"applyEdits\",\n    value: function applyEdits(params, callback, context) {\n      if (params.adds) {\n        var coor = params.adds.geometry.coordinates;\n        var marker = new mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.Marker({\n          'color': params.adds.color ? params.adds.color : ''\n        }).setLngLat(coor).addTo(this.map);\n      }\n\n      return this.service.applyEdits(params, callback, context);\n    }\n  }]);\n\n  return FeatureLayer;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.Evented);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.FeatureLayer = FeatureLayer;\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/FeatureLayer.js?")},"./src/mapboxgl/layer/HeatMapLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HeatMapLayer", function() { return HeatMapLayer; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ "./src/mapboxgl/core/Base.js");\n/* harmony import */ var _core_Parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Parse */ "./src/mapboxgl/core/Parse.js");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Util */ "./src/mapboxgl/core/Util.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.HeatMapLayer\r\n * @classdesc The class of the thermal layer.\r\n * @category  Visualization HeatMap\r\n * @param {string} name The name of the source.\r\n * @param {Object} options Construction parameters.\r\n * @param {mapboxgl.Map} options.map The map object of mapboxgl.\r\n * @param {string} options.id Id of layer.\r\n * @param {number} options.radius=50 The maximum radius of the hotspot rendering (hotspot pixel radius) in px. \r\n * @extends {mapboxgl.Evented}\r\n */\n\nvar HeatMapLayer = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(HeatMapLayer, _mapboxgl$Evented);\n\n  var _super = _createSuper(HeatMapLayer);\n\n  function HeatMapLayer(name, options) {\n    var _this;\n\n    _classCallCheck(this, HeatMapLayer);\n\n    _this = _super.call(this);\n\n    var _options = options ? options : {};\n    /**\r\n    * @member {string} mapboxgl.ekmap.HeatMapLayer.prototype.name\r\n    * @description Name of source.\r\n    */\n\n\n    _this.source = name;\n    /**\r\n    * @member {string} mapboxgl.ekmap.HeatMapLayer.prototype.id\r\n    * @description Id of layer.\r\n    */\n\n    _this.id = _options.id ? _options.id : "heatmap";\n    /**\r\n     * @member {mapboxgl.Map} mapboxgl.ekmap.HeatMapLayer.prototype.map\r\n     * @description map\r\n     */\n\n    _this.map = _options.map ? _options.map : null;\n    /**\r\n     * @member {number} mapboxgl.ekmap.HeatMapLayer.prototype.radius\r\n     * @description map\r\n     */\n\n    _this.radius = _options.radius ? _options.radius : 50;\n    /**\r\n    * @member {string} mapboxgl.ekmap.HeatMapLayer.prototype.type\r\n    * @description Default \'heatmap\'.\r\n    */\n\n    _this.type = \'heatmap\';\n    /**\r\n    * @member {Object} mapboxgl.ekmap.HeatMapLayer.prototype.paint\r\n    * @description  Object.\r\n    * @private\r\n    */\n\n    _this.paint = {\n      "heatmap-weight": 1,\n      "heatmap-intensity": 2,\n      "heatmap-color": ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(33,102,172,0)", 0.2, "rgb(103,169,207)", 0.4, "rgb(209,229,240)", 0.6, "rgb(253,219,199)", 0.8, "rgb(239,138,98)", 1, "rgb(178,24,43)"],\n      "heatmap-radius": _this.radius\n    };\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.HeatMapLayer.prototype.addFeatures\r\n   * @description Add features\r\n   * @param {GeoJSONObject} features \r\n   *\r\n   * @example\r\n   * var geojson = {\r\n   *      "type": "FeatureCollection",\r\n   *      "features": [\r\n   *          {\r\n   *              "type": "feature",\r\n   *              "geometry": {\r\n   *                  "type": "Point",  //只支持point类型\r\n   *                  "coordinates": [0, 0]\r\n   *              },\r\n   *              "properties": {\r\n   *                  "height": Math.random()*9,\r\n   *                  "geoRadius": useGeoRadius?radius:null\r\n   *              }\r\n   *          }\r\n   *      ]\r\n   *   };\r\n   * var heatMapLayer = new mapboxgl.ekmap.HeatMapLayer("heatmaplayer",{"map":map});                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   pLayer = new mapboxgl.ekmap.HeatMapLayer("heatmaplayer",{"featureWeight":"height"});\r\n   * heatMapLayer.addFeatures(geojson);\r\n   * map.addLayer(heatMapLayer);\r\n   */\n\n\n  _createClass(HeatMapLayer, [{\n    key: "addFeatures",\n    value: function addFeatures(features) {\n      this.map.addSource(this.source, {\n        type: "geojson",\n        data: features\n      });\n    }\n  }]);\n\n  return HeatMapLayer;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.Evented);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.HeatMapLayer = HeatMapLayer;\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/HeatMapLayer.js?')},"./src/mapboxgl/layer/Overlay.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Overlay; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * @class mapboxgl.ekmap.Overlay\n * @classdesc mapboxgl.ekmap.Overlay \n * @category  Layer\n * @param {Object} options - Construction parameters.\n * @param {mapboxgl.Map} options.map Adds the layer to the given map or layer group.\n * \n * @extends {mapboxgl.Overlay}\n */\n\nvar Overlay = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(Overlay, _mapboxgl$Evented);\n\n  var _super = _createSuper(Overlay);\n\n  function Overlay(opts) {\n    var _this;\n\n    _classCallCheck(this, Overlay);\n\n    _this = _super.call(this, opts);\n    _this.opts = opts ? opts : {};\n\n    if (_this.opts && _this.opts.map) {\n      _this.map = _this.opts.map;\n    }\n\n    return _this;\n  }\n  /**\n   * to be overwrite in subClass\n   */\n\n\n  _createClass(Overlay, [{\n    key: "_init",\n    value: function _init() {}\n    /**\n     * @private\n     * @function mapboxgl.ekmap.Overlay.prototype.setMap\n     * @description set map for overlay.\n     * @returns {mapboxgl.Map}\n     */\n\n  }, {\n    key: "lnglat2pix",\n\n    /**\n     * @private\n     * @function mapboxgl.ekmap.Overlay.prototype.lnglat2pix\n     * @description use Global map or this.map instance to project.\n     */\n    value: function lnglat2pix(lng, lat) {\n      if (this.map != undefined && this.map.project instanceof Function) {\n        var lnglat = this.map.project(new mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.LngLat(lng, lat));\n        var x = Math.round(lnglat.x),\n            y = Math.round(lnglat.y);\n        return [x, y];\n      }\n\n      return [lng, lat];\n    }\n  }], [{\n    key: "setMap",\n    value: function setMap(map) {\n      this.map = map;\n      return this;\n    }\n  }]);\n\n  return Overlay;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.Evented);\n\n\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.Overlay = Overlay;\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/Overlay.js?')},"./src/mapboxgl/layer/ThreeLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThreeLayer", function() { return ThreeLayer; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _threejs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./threejs */ "./src/mapboxgl/layer/threejs/index.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Vector3 = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"],\n    Shape = three__WEBPACK_IMPORTED_MODULE_0__["Shape"],\n    Mesh = three__WEBPACK_IMPORTED_MODULE_0__["Mesh"],\n    BufferGeometry = three__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"],\n    ExtrudeGeometry = three__WEBPACK_IMPORTED_MODULE_0__["ExtrudeGeometry"];\n/**\r\n * @class mapboxgl.ekmap.ThreeLayer\r\n * @category  Visualization Three\r\n * @classdesc The three layers class.\r\n * @param {string} id  The layer ID.\r\n * @param {string} renderer="gl" The rendering mode of the layer (canvas or WebGL). Value: "gl", "canvas".\r\n * @param {Object} options Initialization parameters.\r\n * @param {Object} options.threeOptions The parameter object initialized by the threejs renderer. For details of the parameters, see:\r\n *          [WebGLRenderer]{@link https://threejs.org/docs/index.html#api/renderers/WebGLRenderer}\r\n *          [CanvasRenderer]{@link https://threejs.org/docs/index.html#examples/renderers/CanvasRenderer}\r\n *\r\n * @extends {mapboxgl.Evented}\r\n * @fires mapboxgl.ekmap.ThreeLayer#render\r\n * @fires mapboxgl.ekmap.ThreeLayer#renderscene\r\n * @example\r\n * var threeLayer = new mapboxgl.ekmap.ThreeLayer(\'three\');\r\n * //Model drawing\r\n * threeLayer.on("initialized", draw);\r\n * threeLayer.addTo(map);\r\n *\r\n * function draw() {\r\n *    var scene=threeLayer.getScene();\r\n *    camera=threeLayer.getCamera();\r\n *    var light = new THREE.PointLight(0xffffff);\r\n *    camera.add(light);\r\n *    var material = new THREE.MeshPhongMaterial({color: 0xff0000});\r\n *    var mesh = this.toThreeMesh(feature.geometry.coordinates, 10, material, true);\r\n *    scene.add(mesh);\r\n * }\r\n *\r\n * There are two ways to overlay a model:</br>\r\n *     1.Call threeLayer.toThreeMesh to directly convert geographic coordinates into a threejs 3D model (for extruded models, such as urban buildings) and then add to the 3D scene.\r\n *     2.Create a mesh using the interface of ThreeJS, then call threeLayer.setPosition to set the geographic location and then add it to the 3D scene.\r\n *\r\n */\n\nvar ThreeLayer = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(ThreeLayer, _mapboxgl$Evented);\n\n  var _super = _createSuper(ThreeLayer);\n\n  function ThreeLayer(id, renderer, options) {\n    var _this;\n\n    _classCallCheck(this, ThreeLayer);\n\n    _this = _super.call(this);\n    _this._layerId = id;\n    _this.options = options;\n    var threeOptions = options && options.threeOptions;\n    _this.renderer = new _threejs__WEBPACK_IMPORTED_MODULE_2__["ThreeLayerRenderer"](_assertThisInitialized(_this), renderer, threeOptions);\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.ThreeLayer.prototype.toThreeShape\r\n   * @description  Create a threejs shape object.\r\n   * @param {Array} coordinates An array of coordinate points.\r\n   * @returns THREE.Shape {@link https://threejs.org/docs/index.html#api/extras/core/Shape} The object of the threejs shape.\r\n   */\n\n\n  _createClass(ThreeLayer, [{\n    key: "toThreeShape",\n    value: function toThreeShape(coordinates) {\n      var _this2 = this;\n\n      if (!coordinates) {\n        return null;\n      }\n\n      var center = this.getCoordinatesCenter(coordinates);\n      var centerPoint = this.lngLatToPosition(center);\n      var outer = coordinates.map(function (coords) {\n        return _this2.lngLatToPosition({\n          lng: coords[0],\n          lat: coords[1]\n        }).sub(centerPoint);\n      });\n      return new Shape(outer);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.toThreeMesh\r\n     * @description Create a threejs Mesh object. Convert geographic coordinates to a threejs 3D model (for extruded models such as urban buildings).\r\n     * @param {Array.<Object>} coordinates An array of coordinate points.\r\n     * @param {number} amount height.\r\n     * @param {THREE.Material} material Threejs material object. reference:：[THREE.Material]{@link https://threejs.org/docs/index.html#api/extras/core/Material}\r\n     * @param {boolean} removeDuplicated Whether to remove duplicate coordinate points.\r\n     * @returns {THREE.Mesh} Threejs Mesh object. reference：[THREE.Mesh]{@link https://threejs.org/docs/index.html#api/objects/Mesh}\r\n     */\n\n  }, {\n    key: "toThreeMesh",\n    value: function toThreeMesh(coordinates, amount, material, removeDuplicated) {\n      if (!coordinates) {\n        return null;\n      }\n\n      var coords = coordinates;\n\n      if (removeDuplicated) {\n        coords = this.removeDuplicatedCoordinates(coordinates);\n      }\n\n      var targetAmount = this.distanceToThreeVector3(amount, amount).x;\n      var shape = this.toThreeShape(coords);\n      var geometry = new ExtrudeGeometry(shape, {\n        \'amount\': targetAmount,\n        \'bevelEnabled\': true\n      });\n      var bufferGeometry = new BufferGeometry().fromGeometry(geometry);\n      var mesh = new Mesh(bufferGeometry, material);\n      var center = this.lngLatToPosition(this.getCoordinatesCenter(coords));\n      mesh.position.set(center.x, center.y, -targetAmount);\n      return mesh;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.addObject\r\n     * @description Set the coordinates (latitude and longitude) of the threejs 3D object.\r\n     * @param {THREE.Object3D} object3D Threejs 3D object. reference：[THREE.Object3D]{@link https://threejs.org/docs/index.html#api/core/Object3D} and subclass object.\r\n     * @param {(Array.<number>|Object)} coordinate The added three object coordinates (latitude and longitude).\r\n     * @returns {this} this\r\n     */\n\n  }, {\n    key: "addObject",\n    value: function addObject(object3D, coordinate) {\n      if (coordinate && object3D) {\n        this.setPosition(object3D, coordinate);\n      }\n\n      this.renderer && this.renderer.scene.add(object3D);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.getScene\r\n     * @description Get the scene object of threejs.\r\n     * @returns {THREE.Scene} Threejs scene object, reference：[THREE.Scene]{@link https://threejs.org/docs/index.html#api/scenes/Scene}\r\n     */\n\n  }, {\n    key: "getScene",\n    value: function getScene() {\n      return this.renderer.scene;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.getCamera\r\n     * @description Get the threejs camera.\r\n     * @returns {THREE.Camera} Threejs camera. reference：[THREE.Camera]{@link https://threejs.org/docs/index.html#api/cameras/Camera}\r\n     */\n\n  }, {\n    key: "getCamera",\n    value: function getCamera() {\n      return this.renderer.camera;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.getThreeRenderer\r\n     * @description Get the threejs renderer.\r\n     * @returns {THREE.WebGLRenderer|THREE.CanvasRenderer} Threejs renderer. reference：\r\n     *                      [THREE.WebGLRenderer]{@link https://threejs.org/docs/index.html#api/renderers/WebGLRenderer}/\r\n     *                      [THREE.CanvasRenderer]{@link https://threejs.org/docs/index.html#examples/renderers/CanvasRenderer}\r\n     */\n\n  }, {\n    key: "getThreeRenderer",\n    value: function getThreeRenderer() {\n      return this.renderer.context;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.clearMesh\r\n     * @description Clear all threejs mesh objects.\r\n     * @returns {this} The object of this.\r\n     */\n\n  }, {\n    key: "clearMesh",\n    value: function clearMesh() {\n      var scene = this.renderer.scene;\n\n      if (!scene) {\n        return this;\n      }\n\n      for (var i = scene.children.length - 1; i >= 0; i--) {\n        if (scene.children[i] instanceof three__WEBPACK_IMPORTED_MODULE_0__["Mesh"]) {\n          scene.remove(scene.children[i]);\n        }\n      }\n\n      return this;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.clearAll\r\n     * @description Clear all threejs objects.\r\n     * @param {boolean} clearCamera Whether to clear the camera at the same time.\r\n     * @returns {this} The object of this.\r\n     */\n\n  }, {\n    key: "clearAll",\n    value: function clearAll(clearCamera) {\n      var scene = this.renderer.scene;\n\n      if (!scene) {\n        return this;\n      }\n\n      for (var i = scene.children.length - 1; i >= 0; i--) {\n        if (!clearCamera && scene.children[i] instanceof three__WEBPACK_IMPORTED_MODULE_0__["Camera"]) {\n          continue;\n        }\n\n        scene.remove(scene.children[i]);\n      }\n\n      return this;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.setPosition\r\n     * @description Set the coordinates (latitude and longitude) of the threejs 3D object.\r\n     * @param {THREE.Object3D} object3D Threejs 3D object, reference：[THREE.Object3D]{@link https://threejs.org/docs/index.html#api/core/Object3D} and subclass object.\r\n     * @param {(Array.<number>|Object)} coordinate The added three object coordinates (latitude and longitude).\r\n     * @returns {this} The object of this.\r\n     */\n\n  }, {\n    key: "setPosition",\n    value: function setPosition(object3D, coordinate) {\n      if (!object3D || !coordinate) {\n        return this;\n      }\n\n      var pos = this.lngLatToPosition(coordinate);\n      object3D.position.set(pos.x, pos.y, pos.z);\n      return this;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.lngLatToPosition\r\n     * @description Longitude and latitude turns three js 3D vector objects.\r\n     * @param {(Array.<number>|Object)} lngLat Latitude and longitude coordinates.\r\n     * @returns {THREE.Vector3} Three js 3D vector object. reference: [THREE.Vector3]{@link https://threejs.org/docs/index.html#api/math/Vector3}\r\n     */\n\n  }, {\n    key: "lngLatToPosition",\n    value: function lngLatToPosition(lngLat) {\n      var zoom = _threejs__WEBPACK_IMPORTED_MODULE_2__["Transform"].projection.nativeMaxZoom;\n      var point = _threejs__WEBPACK_IMPORTED_MODULE_2__["Transform"].lngLatToPoint(lngLat, zoom);\n      return new Vector3(point.x, point.y, -0);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.distanceToThreeVector3\r\n     * @description A threejs 3D missing object that computes new coordinates from a given distance of a given coordinate.\r\n     * @param {number} x x-axis distance in meters.\r\n     * @param {number} y y-axis distance in meters.\r\n     * @param {(Array.<number>|Object)} lngLat Source coordinates.\r\n     * @returns {THREE.Vector3} The threejs 3D missing object of the target point. reference: [THREE.Vector3]{@link https://threejs.org/docs/index.html#api/math/Vector3}\r\n     */\n\n  }, {\n    key: "distanceToThreeVector3",\n    value: function distanceToThreeVector3(x, y, lngLat) {\n      var map = this._map;\n      var center = lngLat || map.getCenter(),\n          maxZoom = _threejs__WEBPACK_IMPORTED_MODULE_2__["Transform"].projection.nativeMaxZoom,\n          targetLngLat = _threejs__WEBPACK_IMPORTED_MODULE_2__["Transform"].locate(center, x, y);\n      var point1 = _threejs__WEBPACK_IMPORTED_MODULE_2__["Transform"].lngLatToPoint(center, maxZoom),\n          point2 = _threejs__WEBPACK_IMPORTED_MODULE_2__["Transform"].lngLatToPoint(targetLngLat, maxZoom);\n      var targetX = Math.abs(point2.x - point1.x) * Math.sign(x);\n      var targetY = Math.abs(point2.y - point1.y) * Math.sign(y);\n      return new Vector3(targetX, targetY, 0);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.removeDuplicatedCoordinates\r\n     * @description Remove the repeated coordinates in the array.\r\n     * @param {(Array.<Array.<number>>)} coordinates An array of coordinates.\r\n     * @returns {(Array.<Array.<number>>)} A new array of coordinates.\r\n     */\n\n  }, {\n    key: "removeDuplicatedCoordinates",\n    value: function removeDuplicatedCoordinates(coordinates) {\n      function equals(point1, point2) {\n        return point1[0] === point2[0] && point1[1] === point2[1];\n      }\n\n      var coords = [].concat(coordinates);\n      var length = coords.length;\n\n      for (var i = length - 1; i >= 1; i--) {\n        if (equals(coords[i], coords[i - 1])) {\n          coords.splice(i, 1);\n        }\n      }\n\n      var isClose = equals(coords[0], coords[coords.length - 1]);\n      isClose && coords.splice(coords.length - 1, 1);\n      return coords;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.getCoordinatesCenter\r\n     * @description Gets the center coordinate of the given coordinate array.\r\n     * @param {(Array.<Array.<number>>)} coordinates An array of coordinates.\r\n     * @returns {Object} A coordinate object containing latitude and longitude.\r\n     */\n\n  }, {\n    key: "getCoordinatesCenter",\n    value: function getCoordinatesCenter(coordinates) {\n      var sumX = 0,\n          sumY = 0,\n          count = 0;\n      var i = 0,\n          len = coordinates.length;\n\n      for (; i < len; i++) {\n        if (coordinates[i]) {\n          sumX += coordinates[i][0];\n          sumY += coordinates[i][1];\n          count++;\n        }\n      }\n\n      return {\n        lng: sumX / count,\n        lat: sumY / count\n      };\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.addTo\r\n     * @description Add a layer to the map.\r\n     * @param {Object} map The object of the map.\r\n     * @returns {this} The object of this\r\n     */\n\n  }, {\n    key: "addTo",\n    value: function addTo(map) {\n      var me = this;\n      me._map = map;\n      me.renderer.setMap(map);\n      me.renderer.render(); //three mbgl 联动(仅联动相机,不执行重绘操作)\n\n      me._map.on(\'render\', this._update.bind(me));\n\n      me._map.on(\'resize\', this._resize.bind(me));\n\n      me.on(\'render\', function () {\n        this.context && this.context.render(this.scene, this.camera);\n      }.bind(me.renderer));\n      return this;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.getCanvasContainer\r\n     * @description Get the three layer container.\r\n     * @returns {HTMLElement} A container for the three layers.\r\n     */\n\n  }, {\n    key: "getCanvasContainer",\n    value: function getCanvasContainer() {\n      return this.renderer.getCanvasContainer();\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.getCanvas\r\n     * @description Get the three layer canvas.\r\n     * @returns {HTMLCanvasElement} The canvas of the three layers.\r\n     */\n\n  }, {\n    key: "getCanvas",\n    value: function getCanvas() {\n      return this.renderer.getCanvas();\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.remove\r\n     * @description Remove the layer.\r\n     */\n\n  }, {\n    key: "remove",\n    value: function remove() {\n      var map = this._map,\n          me = this;\n      map.off(\'render\', me._update.bind(me));\n      map.off(\'resize\', me._resize.bind(me));\n      me.renderer.remove();\n      me._map = null;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.draw\r\n     * @description Provides an external threejs model drawing interface.\r\n     * @param {THREE.WebGLRenderer|THREE.CanvasRenderer} gl Threejs renderer context. For details, please refer to：</br>\r\n     *          [WebGLRenderer]{@link https://threejs.org/docs/index.html#api/renderers/WebGLRenderer}/\r\n     *          [CanvasRenderer]{@link https://threejs.org/docs/index.html#examples/renderers/CanvasRenderer}\r\n     * @param {THREE.Scene} scene Threejs scene object. For details, please refer to：[THREE.Scene]{@link https://threejs.org/docs/index.html#api/scenes/Scene}\r\n     * @param {THREE.Camera} camera Threejs camera object. For details, please refer to: [THREE.Camera]{@link https://threejs.org/docs/index.html#api/cameras/Camera}\r\n     * @returns {this} The object of this.\r\n     * @example\r\n     * var threeLayer = new mapboxgl.ekmap.ThreeLayer(\'three\');\r\n     * //Can be modeled by overriding draw\r\n     * threeLayer.draw = function (gl, scene, camera) {\r\n     *     //TODO drawing operation.\r\n     * }\r\n     * threeLayer.addTo(map);\r\n     */\n\n  }, {\n    key: "draw",\n    value: function draw(gl, scene, camera) {\n      return this;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.ThreeLayer.prototype.renderScene\r\n     * @description Rendered scenes.\r\n     * @returns {this} this\r\n     */\n\n  }, {\n    key: "renderScene",\n    value: function renderScene() {\n      this.renderer.renderScene();\n      /**\r\n       * @event mapboxgl.ekmap.ThreeLayer#renderscene\r\n       * @description renderScene Event, triggered after the scene is rendered.\r\n       */\n\n      this.fire("renderscene");\n      return this;\n    }\n  }, {\n    key: "_resize",\n    value: function _resize() {\n      this.renderer.resize();\n    }\n  }, {\n    key: "_update",\n    value: function _update() {\n      /**\r\n       * @event mapboxgl.ekmap.ThreeLayer#render\r\n       * @description render event, triggered when the map is rendered (when the map state changes).\r\n       */\n      this.renderScene();\n      this.fire(\'render\');\n      return this;\n    }\n  }]);\n\n  return ThreeLayer;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.Evented);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.ThreeLayer = ThreeLayer;\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/ThreeLayer.js?')},"./src/mapboxgl/layer/TiledAdminMapLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiledAdminMapLayer", function() { return TiledAdminMapLayer; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _TiledMapLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TiledMapLayer */ "./src/mapboxgl/layer/TiledMapLayer.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/**\r\n * @class mapboxgl.ekmap.TiledAdminMapLayer\r\n * @classdesc The TiledAdminMapLayer class.\r\n * @category  Layer\r\n * @param {Object} options  Construction parameters.\r\n * @param {string} options.token  Will use this token to authenticate all calls to the service.\r\n * @extends {mapboxgl.ekmap.TiledMapLayer}\r\n * @example\r\n * var map = new mapboxgl.Map({\r\n *     container: \'map1\',\r\n *     center: [103.9, 22.2],\r\n *     zoom: 6\r\n * });\r\n * var adminMap = new mapboxgl.ekmap.TiledAdminMapLayer({\r\n *      token: {YOUR_API_KEY}\r\n * })\r\n *   .addTo(map);\r\n */\n\nvar TiledAdminMapLayer = /*#__PURE__*/function (_TiledMapLayer) {\n  _inherits(TiledAdminMapLayer, _TiledMapLayer);\n\n  var _super = _createSuper(TiledAdminMapLayer);\n\n  function TiledAdminMapLayer(options) {\n    var _this;\n\n    _classCallCheck(this, TiledAdminMapLayer);\n\n    _this = _super.call(this);\n    _this.options = options ? options : {};\n    _this.urls = ["https://g1.cloudgis.vn/gservices/rest/maps/adminmap/tile/{z}/{x}/{y}.png", "https://g2.cloudgis.vn/gservices/rest/maps/adminmap/tile/{z}/{x}/{y}.png", "https://g3.cloudgis.vn/gservices/rest/maps/adminmap/tile/{z}/{x}/{y}.png", "https://g4.cloudgis.vn/gservices/rest/maps/adminmap/tile/{z}/{x}/{y}.png"];\n    _this.urlsToken = [];\n    if (options) _this.urls.forEach(function (url) {\n      url += "?apikey=" + options.token;\n\n      _this.urlsToken.push(url);\n    });\n\n    if (_this.urlsToken.length > 0) {\n      _this.tiledMapLayer = new mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.TiledMapLayer({\n        urls: _this.urlsToken\n      });\n    } else {\n      _this.tiledMapLayer = new mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.TiledMapLayer({\n        urls: _this.urls\n      });\n    }\n\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.TiledAdminMapLayer.prototype.addTo\r\n   * @description Adds the layer to the given map or layer group.\r\n   * @param {mapboxgl.Map} map - Adds the layer to the given map or layer group.\r\n   * @returns this\r\n   */\n\n\n  _createClass(TiledAdminMapLayer, [{\n    key: "addTo",\n    value: function addTo(map) {\n      return this.tiledMapLayer.addTo(map);\n    }\n  }]);\n\n  return TiledAdminMapLayer;\n}(_TiledMapLayer__WEBPACK_IMPORTED_MODULE_1__["TiledMapLayer"]);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.TiledAdminMapLayer = TiledAdminMapLayer;\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/TiledAdminMapLayer.js?')},"./src/mapboxgl/layer/TiledMapLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiledMapLayer", function() { return TiledMapLayer; });\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Util */ "./src/mapboxgl/core/Util.js");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/**\r\n * @class mapboxgl.ekmap.TiledMapLayer\r\n * @classdesc The TiledMapLayer class.\r\n * @category  Layer\r\n * @param {Object} options - Construction parameters.\r\n * @param {string} options.url - Required: URL of the {@link https://developers.arcgis.com/rest/services-reference/layer-feature-service-.htm|Map Service} with a tile cache.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n * @extends {mapboxgl.Evented}\r\n */\n\nvar TiledMapLayer = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(TiledMapLayer, _mapboxgl$Evented);\n\n  var _super = _createSuper(TiledMapLayer);\n\n  function TiledMapLayer(options) {\n    var _this;\n\n    _classCallCheck(this, TiledMapLayer);\n\n    _this = _super.call(this);\n    _this.options = options ? options : {};\n\n    if (options) {\n      options = _core_Util__WEBPACK_IMPORTED_MODULE_0__["Util"].setOptions(_assertThisInitialized(_this), options); // set the urls\n\n      if (options.url) {\n        options = _core_Util__WEBPACK_IMPORTED_MODULE_0__["Util"].getUrlParams(options);\n        _this.tileUrl = (options.proxy ? options.proxy + \'?\' : \'\') + options.url + \'tile/{z}/{y}/{x}\' + (options.requestParams && Object.keys(options.requestParams).length > 0 ? _core_Util__WEBPACK_IMPORTED_MODULE_0__["Util"].getParamString(options.requestParams) : \'\'); //if (options.url.indexOf(\'{s}\') !== -1 && options.subdomains && options.url)\n        //    options.url = options.url.replace(\'{s}\', options.subdomains[0]);\n\n        _this.service = new mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.MapService(options);\n      }\n\n      if (options.urls) _this.tileUrls = options.urls; // Remove subdomain in url\n      // https://github.com/Esri/esri-leaflet/issues/991\n      //this.service.addEventParent(this);\n      //var arcgisonline = new RegExp(/tiles.arcgis(online)?\\.com/g);\n      //if (arcgisonline.test(options.url)) {\n      //    this.tileUrl = this.tileUrl.replace(\'://tiles\', \'://tiles{s}\');\n      //    options.subdomains = [\'1\', \'2\', \'3\', \'4\'];\n      //}\n\n      if (_this.options.token) {\n        _this.tileUrl += \'?token=\' + _this.options.token;\n      } //return new mapboxgl.ekmap.MapService(this.tileUrl);\n      // init layer by calling TileLayers initialize method\n      //TileLayer.prototype.initialize.call(this, this.tileUrl, options);\n\n    }\n\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.TiledMapLayer.prototype.addTo\r\n   * @description Adds the layer to the given map or layer group.\r\n   * @param {mapboxgl.Map} map - Adds the layer to the given map or layer group.\r\n   * @returns this\r\n   */\n\n\n  _createClass(TiledMapLayer, [{\n    key: "addTo",\n    value: function addTo(map) {\n      var nameID = \'raster-tiles\';\n      var id = Math.round(Math.random() * 100);\n\n      if (this.tileUrl) {\n        map.addSource(nameID + id, {\n          "type": "raster",\n          "tiles": [this.tileUrl],\n          "tileSize": 256\n        });\n        map.addLayer({\n          "id": nameID + id,\n          "type": "raster",\n          "source": nameID + id,\n          "minzoom": 0,\n          "maxzoom": 22,\n          \'layout\': {\n            \'visibility\': \'visible\'\n          },\n          \'metadata\': {\n            \'type\': \'overlayer\',\n            \'url\': this.options.url,\n            \'token\': this.options.token ? this.options.token : ""\n          }\n        });\n      }\n\n      if (this.tileUrls) {\n        map.addSource(nameID + id, {\n          "type": "raster",\n          "tiles": this.tileUrls,\n          "tileSize": 256\n        });\n        map.addLayer({\n          "id": nameID + id,\n          "type": "raster",\n          "source": nameID + id,\n          "minzoom": 0,\n          "maxzoom": 22,\n          \'layout\': {\n            \'visibility\': \'visible\'\n          },\n          \'metadata\': {\n            \'type\': \'overlayer\' //\'url\': \'http://s2.cloudgis.vn/arcgis/rest/services/GIS/VietNam/MapServer/\',\n            //\'layers\': [\n            //    {\n            //        id: \'Thủy điện\',\n            //        geometryType: \'esriGeometryPoint\',\n            //        url: \'http://s2.cloudgis.vn/arcgis/rest/services/GIS/VietNam/FeatureServer/0/\'\n            //    },\n            //    {\n            //        id: \'Đường giao thông\',\n            //        geometryType: \'esriGeometryPolyline\',\n            //        url: \'http://s2.cloudgis.vn/arcgis/rest/services/GIS/VietNam/FeatureServer/1/\'\n            //    },\n            //    {\n            //        id: \'Địa phận tỉnh\',\n            //        geometryType: \'esriGeometryPolygon\',\n            //        url: \'http://s2.cloudgis.vn/arcgis/rest/services/GIS/VietNam/FeatureServer/2/\'\n            //    }\n            //]\n\n          }\n        });\n      }\n\n      return this;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.TiledMapLayer.prototype.identity\r\n     * @description Returns a new mapboxgl.ekmap.IdentifyFeatures object that can be used to identify features on this layer. Your callback function will be passed a GeoJSON FeatureCollection with the results or an error.\r\n     * @returns this\r\n     */\n\n  }, {\n    key: "identify",\n    value: function identify() {\n      return this.service.identify();\n    }\n    /**\r\n     * @function mapboxgl.ekmap.TiledMapLayer.prototype.find\r\n     * @description Adds the layer to the given map or layer group.\r\n     * @param {Object} params - Adds the layer to the given map or layer group.\r\n     * @param {RequestCallback} callback \r\n     */\n\n  }, {\n    key: "find",\n    value: function find(params, callback, context) {\n      return this.service.find(params, callback, context);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.TiledMapLayer.prototype.legend\r\n     * @description legend of Tiled Map Layer.\r\n     * @param {RequestCallback} callback\r\n     *\r\n     */\n\n  }, {\n    key: "legend",\n    value: function legend(callback, context) {\n      return this.service.legend(callback, context);\n    }\n  }]);\n\n  return TiledMapLayer;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.Evented);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TiledMapLayer = TiledMapLayer;\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/TiledMapLayer.js?')},"./src/mapboxgl/layer/TiledOSMapLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiledOSMapLayer", function() { return TiledOSMapLayer; });\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Util */ "./src/mapboxgl/core/Util.js");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TiledMapLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TiledMapLayer */ "./src/mapboxgl/layer/TiledMapLayer.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.TiledOSMapLayer\r\n * @classdesc The TiledOSMapLayer class.\r\n * @category Visualization TiledMap\r\n * @param {Object} options - Control options.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n * @extends {mapboxgl.ekmap.TiledMapLayer}\r\n * @example\r\n * var map = new mapboxgl.Map({\r\n *     container: \'divMapId\',\r\n *     center: [103.9, 22.2],\r\n *     zoom: 6\r\n * });\r\n * var OSMap = new mapboxgl.ekmap.TiledOSMapLayer({})\r\n *   .addTo(map);\r\n */\n\nvar TiledOSMapLayer = /*#__PURE__*/function (_TiledMapLayer) {\n  _inherits(TiledOSMapLayer, _TiledMapLayer);\n\n  var _super = _createSuper(TiledOSMapLayer);\n\n  function TiledOSMapLayer(options) {\n    var _this;\n\n    _classCallCheck(this, TiledOSMapLayer);\n\n    _this = _super.call(this);\n    _this.options = options ? options : {};\n    _this.urls = ["https://a.tile.openstreetmap.org/{z}/{x}/{y}.png", "https://b.tile.openstreetmap.org/{z}/{x}/{y}.png", "https://c.tile.openstreetmap.org/{z}/{x}/{y}.png"];\n    _this.urlsToken = [];\n    if (options) _this.urls.forEach(function (url) {\n      url += "?apikey=" + options.token;\n\n      _this.urlsToken.push(url);\n    });\n\n    if (_this.urlsToken.length > 0) {\n      _this.tiledMapLayer = new mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TiledMapLayer({\n        urls: _this.urlsToken\n      });\n    } else {\n      _this.tiledMapLayer = new mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TiledMapLayer({\n        urls: _this.urls\n      });\n    }\n\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.TiledOSMapLayer.prototype.addTo\r\n   * @description Adds the layer to the given map or layer group.\r\n   * @param {mapboxgl.Map} map - Adds the layer to the given map or layer group.\r\n   * @returns this\r\n   */\n\n\n  _createClass(TiledOSMapLayer, [{\n    key: "addTo",\n    value: function addTo(map) {\n      return this.tiledMapLayer.addTo(map);\n    }\n  }]);\n\n  return TiledOSMapLayer;\n}(_TiledMapLayer__WEBPACK_IMPORTED_MODULE_2__["TiledMapLayer"]);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TiledOSMapLayer = TiledOSMapLayer;\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/TiledOSMapLayer.js?')},"./src/mapboxgl/layer/TiledRoadMapLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TiledRoadMapLayer", function() { return TiledRoadMapLayer; });\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Util */ "./src/mapboxgl/core/Util.js");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TiledMapLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TiledMapLayer */ "./src/mapboxgl/layer/TiledMapLayer.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.TiledRoadMapLayer\r\n * @classdesc The TiledRoadMapLayer class.\r\n * @category Layer\r\n * @param {Object} options - Control options.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n * @extends {mapboxgl.ekmap.TiledMapLayer}\r\n * @example\r\n * var map = new mapboxgl.Map({\r\n *     container: \'map1\',\r\n *     center: [103.9, 22.2],\r\n *     zoom: 6\r\n * });\r\n * var roadMap = new mapboxgl.ekmap.TiledRoadMapLayer({})\r\n *   .addTo(map);\r\n */\n\nvar TiledRoadMapLayer = /*#__PURE__*/function (_TiledMapLayer) {\n  _inherits(TiledRoadMapLayer, _TiledMapLayer);\n\n  var _super = _createSuper(TiledRoadMapLayer);\n\n  function TiledRoadMapLayer(options) {\n    var _this;\n\n    _classCallCheck(this, TiledRoadMapLayer);\n\n    _this = _super.call(this);\n    _this.options = options ? options : {};\n    _this.urls = ["https://g1.cloudgis.vn/gservices/rest/maps/roadmap/tile/{z}/{x}/{y}.png", "https://g2.cloudgis.vn/gservices/rest/maps/roadmap/tile/{z}/{x}/{y}.png", "https://g3.cloudgis.vn/gservices/rest/maps/roadmap/tile/{z}/{x}/{y}.png", "https://g4.cloudgis.vn/gservices/rest/maps/roadmap/tile/{z}/{x}/{y}.png"];\n    _this.urlsToken = [];\n    if (options) _this.urls.forEach(function (url) {\n      url += "?apikey=" + options.token;\n\n      _this.urlsToken.push(url);\n    });\n\n    if (_this.urlsToken.length > 0) {\n      _this.tiledMapLayer = new mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TiledMapLayer({\n        urls: _this.urlsToken\n      });\n    } else {\n      _this.tiledMapLayer = new mapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TiledMapLayer({\n        urls: _this.urls\n      });\n    }\n\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.TiledRoadMapLayer.prototype.addTo\r\n   * @description Adds the layer to the given map or layer group.\r\n   * @param {mapboxgl.Map} map - Adds the layer to the given map or layer group.\r\n   * @returns this\r\n   */\n\n\n  _createClass(TiledRoadMapLayer, [{\n    key: "addTo",\n    value: function addTo(map) {\n      return this.tiledMapLayer.addTo(map);\n    }\n  }]);\n\n  return TiledRoadMapLayer;\n}(_TiledMapLayer__WEBPACK_IMPORTED_MODULE_2__["TiledMapLayer"]);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_1___default.a.ekmap.TiledRoadMapLayer = TiledRoadMapLayer;\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/TiledRoadMapLayer.js?')},"./src/mapboxgl/layer/VectorTiledMapLayer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorTiledMapLayer", function() { return VectorTiledMapLayer; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\r\n * @class mapboxgl.ekmap.VectorTiledMapLayer\r\n * @classdesc The VectorTiledMapLayer class.\r\n * @category Layer\r\n * @param {string} url - Url Vector Tile Services.\r\n * @extends {mapboxgl.Evented}\r\n */\n\nvar VectorTiledMapLayer = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(VectorTiledMapLayer, _mapboxgl$Evented);\n\n  var _super = _createSuper(VectorTiledMapLayer);\n\n  function VectorTiledMapLayer(url) {\n    var _this;\n\n    _classCallCheck(this, VectorTiledMapLayer);\n\n    _this = _super.call(this);\n    _this.url = url;\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.VectorTiledMapLayer.prototype.addTo\r\n   * @description Adds the layer to the given map or layer group.\r\n   * @param {mapboxgl.Map} map - Adds the layer to the given map or layer group.\r\n   * @returns this\r\n   */\n\n\n  _createClass(VectorTiledMapLayer, [{\n    key: "addTo",\n    value: function addTo(map) {\n      map.setStyle(this.url);\n      return this;\n    }\n  }]);\n\n  return VectorTiledMapLayer;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.Evented);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.VectorTiledMapLayer = VectorTiledMapLayer;\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/VectorTiledMapLayer.js?')},"./src/mapboxgl/layer/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _HeatMapLayer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HeatMapLayer */ "./src/mapboxgl/layer/HeatMapLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HeatMapLayer", function() { return _HeatMapLayer__WEBPACK_IMPORTED_MODULE_0__["HeatMapLayer"]; });\n\n/* harmony import */ var _TiledMapLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TiledMapLayer */ "./src/mapboxgl/layer/TiledMapLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledMapLayer", function() { return _TiledMapLayer__WEBPACK_IMPORTED_MODULE_1__["TiledMapLayer"]; });\n\n/* harmony import */ var _VectorTiledMapLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VectorTiledMapLayer */ "./src/mapboxgl/layer/VectorTiledMapLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VectorTiledMapLayer", function() { return _VectorTiledMapLayer__WEBPACK_IMPORTED_MODULE_2__["VectorTiledMapLayer"]; });\n\n/* harmony import */ var _TiledRoadMapLayer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TiledRoadMapLayer */ "./src/mapboxgl/layer/TiledRoadMapLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledRoadMapLayer", function() { return _TiledRoadMapLayer__WEBPACK_IMPORTED_MODULE_3__["TiledRoadMapLayer"]; });\n\n/* harmony import */ var _TiledAdminMapLayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TiledAdminMapLayer */ "./src/mapboxgl/layer/TiledAdminMapLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledAdminMapLayer", function() { return _TiledAdminMapLayer__WEBPACK_IMPORTED_MODULE_4__["TiledAdminMapLayer"]; });\n\n/* harmony import */ var _TiledOSMapLayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TiledOSMapLayer */ "./src/mapboxgl/layer/TiledOSMapLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TiledOSMapLayer", function() { return _TiledOSMapLayer__WEBPACK_IMPORTED_MODULE_5__["TiledOSMapLayer"]; });\n\n/* harmony import */ var _FeatureLayer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FeatureLayer */ "./src/mapboxgl/layer/FeatureLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FeatureLayer", function() { return _FeatureLayer__WEBPACK_IMPORTED_MODULE_6__["FeatureLayer"]; });\n\n/* harmony import */ var _ThreeLayer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ThreeLayer */ "./src/mapboxgl/layer/ThreeLayer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ThreeLayer", function() { return _ThreeLayer__WEBPACK_IMPORTED_MODULE_7__["ThreeLayer"]; });\n\n/* harmony import */ var _DomOverlay__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DomOverlay */ "./src/mapboxgl/layer/DomOverlay.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DomOverlay", function() { return _DomOverlay__WEBPACK_IMPORTED_MODULE_8__["DomOverlay"]; });\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/index.js?')},"./src/mapboxgl/layer/threejs/ThreeLayerRenderer.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThreeLayerRenderer", function() { return ThreeLayerRenderer; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "three");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transform */ "./src/mapboxgl/layer/threejs/Transform.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar projection = _Transform__WEBPACK_IMPORTED_MODULE_1__["Transform"].projection;\nvar Color = three__WEBPACK_IMPORTED_MODULE_0__["Color"],\n    Scene = three__WEBPACK_IMPORTED_MODULE_0__["Scene"],\n    WebGLRenderer = three__WEBPACK_IMPORTED_MODULE_0__["WebGLRenderer"],\n    CanvasRenderer = three__WEBPACK_IMPORTED_MODULE_0__["CanvasRenderer"],\n    PerspectiveCamera = three__WEBPACK_IMPORTED_MODULE_0__["PerspectiveCamera"];\nvar RADIAN = Math.PI / 180;\nvar frame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\nvar cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n/**\r\n * @private\r\n * @class ThreeLayerRenderer\r\n * @category  Visualization Three\r\n * @classdesc Three\r\n * @param {mapboxgl.ekmap.ThreeLayer} layer ThreeJs\r\n * @param {string} renderer="gl" The rendering mode of the layer (canvas or WebGL). Value: "gl", "canvas".\r\n * @param {Object} options The parameter object initialized by the threejs renderer. For details of the parameters, see:\r\n *          [WebGLRenderer]{@link https://threejs.org/docs/index.html#api/renderers/WebGLRenderer}/\r\n *          [CanvasRenderer]{@link https://threejs.org/docs/index.html#examples/renderers/CanvasRenderer}\r\n *\r\n * @extends {mapboxgl.Evented}\r\n * @fires mapboxgl.ekmap.ThreeLayer#initialized\r\n * @fires mapboxgl.ekmap.ThreeLayer#draw\r\n * @fires mapboxgl.ekmap.ThreeLayer#rendererinitialized\r\n */\n\nvar ThreeLayerRenderer = /*#__PURE__*/function () {\n  function ThreeLayerRenderer(layer, renderer, options) {\n    _classCallCheck(this, ThreeLayerRenderer);\n\n    this._layer = layer;\n    this.renderer = renderer || "gl";\n    this.options = options;\n  }\n\n  _createClass(ThreeLayerRenderer, [{\n    key: "setMap",\n    value: function setMap(map) {\n      this.map = map;\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      if (!this._layer) {\n        return;\n      }\n\n      this.prepare();\n      /**\r\n       * @private\r\n       * @event mapboxgl.ekmap.ThreeLayer#initialized\r\n       * @description three \r\n       */\n\n      this._layer.fire("initialized");\n\n      this._layer && this._layer.draw(this.context, this.scene, this.camera);\n      /**\r\n       * @event mapboxgl.ekmap.ThreeLayer#draw\r\n       * @description draw event, trigger after calling the interface provided for external drawing.\r\n       */\n\n      this._layer.fire("draw");\n\n      this.renderScene();\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      this.remove();\n      this.render();\n    }\n  }, {\n    key: "renderScene",\n    value: function renderScene() {\n      this.locationCamera();\n      this.animationFrame = this.renderFrame(function () {\n        this.animationFrame = null;\n        this.context && this.context.render(this.scene, this.camera);\n      }.bind(this));\n    }\n  }, {\n    key: "renderFrame",\n    value: function renderFrame(fn) {\n      var render = function render() {\n        fn && typeof fn === "function" && fn();\n      };\n\n      return frame(render);\n    }\n  }, {\n    key: "resize",\n    value: function resize() {\n      this._resetElementSize(this.container);\n\n      this._resetElementSize(this.canvas);\n\n      var width = this.canvas.width,\n          height = this.canvas.height;\n      var size = this.getMapSize();\n      this.camera.aspect = width / height;\n      this.camera.updateProjectionMatrix();\n      this.context.setSize(size.width, size.height);\n      this.renderScene();\n    }\n  }, {\n    key: "prepare",\n    value: function prepare() {\n      if (!this.map) {\n        return new Error("map object is necessary");\n      }\n\n      if (!this.canvas) {\n        this._initContainer();\n\n        this._initThreeRenderer();\n        /**\r\n         * @event mapboxgl.ekmap.ThreeLayer#rendererinitialized\r\n         * @description rendererinitialized event, trigger after renderer initializing.\r\n         */\n\n\n        this._layer.fire("rendererinitialized");\n      } else {\n        this.clear(this.context);\n      }\n    }\n  }, {\n    key: "getMapSize",\n    value: function getMapSize() {\n      var container = this.map.getContainer();\n      return {\n        width: container.clientWidth,\n        height: container.clientHeight\n      };\n    }\n  }, {\n    key: "cancelFrame",\n    value: function cancelFrame() {\n      if (this.animationFrame != null) {\n        cancel(this.animationFrame);\n      }\n    }\n  }, {\n    key: "remove",\n    value: function remove() {\n      if (this.animationFrame != null) {\n        cancel(this.animationFrame);\n      }\n\n      this.container.removeChild(this.canvas);\n      this.container.parentNode.removeChild(this.container);\n      this.context = null;\n      this.canvas = null;\n      this.container = null;\n    }\n  }, {\n    key: "clear",\n    value: function clear(context) {\n      context && context.clear && context.clear();\n      context && context.clearRect && context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n    }\n  }, {\n    key: "getScale",\n    value: function getScale(zoom) {\n      var map = this.map;\n      var z = zoom == null ? map.getZoom() : zoom;\n      var max = projection.getResolution(projection.nativeMaxZoom),\n          res = projection.getResolution(z);\n      return res / max;\n    }\n  }, {\n    key: "getCanvasContainer",\n    value: function getCanvasContainer() {\n      return this.container;\n    }\n  }, {\n    key: "getCanvas",\n    value: function getCanvas() {\n      return this.canvas;\n    }\n  }, {\n    key: "locationCamera",\n    value: function locationCamera() {\n      var map = this.map;\n      var size = this.getMapSize();\n      var scale = map.transform.zoomScale(projection.nativeMaxZoom - map.getZoom() - 1);\n      var fovRatio = Math.tan(map.transform.fov / 2 * RADIAN);\n      var camera = this.camera;\n      var pitch = map.getPitch() * RADIAN;\n      var pZ = -scale * size.height / 2 / fovRatio;\n      camera.position.z = pZ * Math.cos(pitch);\n      var centerPoint = _Transform__WEBPACK_IMPORTED_MODULE_1__["Transform"].lngLatToPoint(map.getCenter(), projection.nativeMaxZoom);\n      var distance = Math.sin(pitch) * pZ;\n      var bearing = map.getBearing() * RADIAN;\n      camera.position.x = centerPoint.x + distance * Math.sin(bearing);\n      camera.position.y = centerPoint.y - distance * Math.cos(bearing);\n      camera.up.set(Math.sin(bearing), -Math.cos(bearing), 0);\n      camera.lookAt(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](centerPoint.x, centerPoint.y, 0));\n      camera.updateProjectionMatrix();\n    }\n  }, {\n    key: "_initContainer",\n    value: function _initContainer() {\n      var canvas = this._createCanvas();\n\n      var container = this.container = document.createElement("div");\n\n      if (this._layer._layerId) {\n        container.id = this._layer._layerId;\n      }\n\n      container.className = "threejs-wrapper";\n      container.style.position = "absolute";\n      container.style.left = "0px";\n      container.style.top = "0px";\n      container.style.overflow = "hidden";\n\n      this._resetElementSize(container);\n\n      container.appendChild(canvas);\n      var mapContainer = this.map.getCanvasContainer();\n      mapContainer.appendChild(container);\n    }\n  }, {\n    key: "_createCanvas",\n    value: function _createCanvas() {\n      if (this.canvas) {\n        return;\n      }\n\n      var canvas = this.canvas = document.createElement(\'canvas\');\n      canvas.className = "threejs-overlay";\n      canvas.style.outline = "none";\n\n      this._resetElementSize(canvas);\n\n      return canvas;\n    }\n  }, {\n    key: "_resetElementSize",\n    value: function _resetElementSize(element) {\n      if (!element) {\n        return;\n      }\n\n      var size = this.getMapSize();\n      var dpr = window.devicePixelRatio ? window.devicePixelRatio : 1;\n      var width = dpr * size.width;\n      var height = dpr * size.height;\n      element.width = width;\n      element.height = height;\n      element.style.width = size.width + \'px\';\n      element.style.height = size.height + \'px\';\n    }\n  }, {\n    key: "_initThreeRenderer",\n    value: function _initThreeRenderer() {\n      var map = this.map;\n      var size = this.getMapSize();\n      var renderer = this.renderer || \'gl\';\n      var context;\n\n      if (renderer === \'gl\') {\n        context = new WebGLRenderer({\n          \'canvas\': this.canvas,\n          \'alpha\': true,\n          \'antialias\': true,\n          \'preserveDrawingBuffer\': true\n        }, this.options);\n        context.autoClear = true;\n        context.clear();\n      } else {\n        context = new CanvasRenderer(Util.extend({\n          \'canvas\': this.canvas,\n          \'alpha\': true\n        }, this.options));\n      }\n\n      context.setClearColor(new Color(1, 1, 1), 0);\n      context.canvas = this.canvas;\n      this.context = context;\n      var fov = map.transform.fov;\n      var fovRatio = Math.tan(fov / 2 * RADIAN);\n      var maxScale = this.getScale(projection.minZoom) / this.getScale(projection.nativeMaxZoom);\n      var far = maxScale * size.height / 2 / fovRatio;\n      this.camera = new PerspectiveCamera(fov, size.width / size.height, 1, far);\n      this.scene = new Scene();\n      this.scene.add(this.camera);\n    }\n  }]);\n\n  return ThreeLayerRenderer;\n}();\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/threejs/ThreeLayerRenderer.js?')},"./src/mapboxgl/layer/threejs/Transform.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Projection", function() { return Projection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Base */ "./src/mapboxgl/core/Base.js");\n\n\nfunction wrap(source, min, max) {\n  if (source === max || source === min) {\n    return source;\n  }\n\n  var len = max - min;\n  return ((source - min) % len + len) % len + min;\n}\n\nfunction rad(angle) {\n  return angle * Math.PI / 180;\n}\n\nvar Projection = {\n  R: 6378137,\n  minZoom: 0,\n  maxZoom: 22,\n  nativeMaxZoom: 19,\n  RAD: Math.PI / 180,\n  METERS_PER_DEGREE: 6378137 * Math.PI / 180,\n  MAX_LATITUDE: 85.0511287798,\n  project: function project(lngLat) {\n    var rad = this.RAD,\n        metersPerDegree = this.METERS_PER_DEGREE,\n        max = this.MAX_LATITUDE;\n    var ll = lngLat instanceof Array ? {\n      lng: lngLat[0],\n      lat: lngLat[1]\n    } : {\n      lng: lngLat.lng,\n      lat: lngLat.lat\n    };\n    var lng = ll.lng,\n        lat = Math.max(Math.min(max, ll.lat), -max);\n    var c;\n\n    if (lat === 0) {\n      c = 0;\n    } else {\n      c = Math.log(Math.tan((90 + lat) * rad / 2)) / rad;\n    }\n\n    return {\n      x: lng * metersPerDegree,\n      y: c * metersPerDegree\n    };\n  },\n  unproject: function unproject(point) {\n    var x = point.x,\n        y = point.y;\n    var rad = this.RAD,\n        metersPerDegree = this.METERS_PER_DEGREE;\n    var c;\n\n    if (y === 0) {\n      c = 0;\n    } else {\n      c = y / metersPerDegree;\n      c = (2 * Math.atan(Math.exp(c * rad)) - Math.PI / 2) / rad;\n    }\n\n    return {\n      lng: wrap(x / metersPerDegree, -180, 180),\n      lat: wrap(c, -this.MAX_LATITUDE, this.MAX_LATITUDE)\n    };\n  },\n  locate: function locate(lngLat, dx, dy) {\n    if (!lngLat) {\n      return null;\n    }\n\n    dx = !dx ? 0 : dx;\n    dy = !dy ? 0 : dy;\n\n    if (!dx && !dy) {\n      return lngLat;\n    }\n\n    var lng = lngLat.lng;\n\n    if (dx !== 0) {\n      var ndx = Math.abs(dx),\n          radLng = rad(lngLat.lng);\n      var sLng = 2 * Math.sqrt(Math.pow(Math.sin(ndx / (2 * this.R)), 2) / Math.pow(Math.cos(radLng), 2));\n      radLng = radLng + sLng * (ndx > 0 ? 1 : -1);\n      lng = wrap(radLng * 180 / Math.PI, -180, 180);\n    }\n\n    var lat = lngLat.lat;\n\n    if (dy !== 0) {\n      var ndy = Math.abs(dy),\n          radLat = rad(lngLat.lat);\n      var sLat = Math.sin(ndy / (2 * this.R)) * 2;\n      radLat = radLat + sLat * (ndy > 0 ? 1 : -1);\n      lat = wrap(radLat * 180 / Math.PI, -90, 90);\n    }\n\n    return {\n      lng: lng,\n      lat: lat\n    };\n  },\n  getResolution: function getResolution(zoom) {\n    if (!this.resolutions) {\n      var resolutions = [];\n      var d = 2 * 6378137 * Math.PI;\n\n      for (var i = 0; i <= this.maxZoom; i++) {\n        resolutions[i] = d / (256 * Math.pow(2, i));\n      }\n\n      this.resolutions = resolutions;\n    }\n\n    var z = zoom | 0,\n        length = this.resolutions.length;\n    z = z < 0 ? 0 : z > length - 1 ? length - 1 : z;\n    var res = this.resolutions[z];\n\n    if ((zoom | 0) !== zoom && z !== length - 1) {\n      var next = this.resolutions[z + 1];\n      return res + (next - res) * (zoom - z);\n    }\n\n    return res;\n  }\n};\nvar Transform = {\n  matrix: [1, -1, 0, 0],\n  projection: Projection,\n  project: function project(lngLat) {\n    return this.projection.project(lngLat);\n  },\n  unproject: function unproject(point) {\n    return this.projection.unproject(point);\n  },\n  lngLatToPoint: function lngLatToPoint(lngLat, zoom) {\n    var pt = this.project(lngLat);\n    return this.transform(pt, this.projection.getResolution(zoom));\n  },\n  locate: function locate(lngLat, dx, dy) {\n    return this.projection.locate(lngLat, dx, dy);\n  },\n  transform: function transform(point, scale) {\n    return {\n      x: this.matrix[0] * (point.x - this.matrix[2]) / scale,\n      y: this.matrix[1] * (point.y - this.matrix[3]) / scale\n    };\n  }\n};\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/threejs/Transform.js?')},"./src/mapboxgl/layer/threejs/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ThreeLayerRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ThreeLayerRenderer */ "./src/mapboxgl/layer/threejs/ThreeLayerRenderer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ThreeLayerRenderer", function() { return _ThreeLayerRenderer__WEBPACK_IMPORTED_MODULE_0__["ThreeLayerRenderer"]; });\n\n/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transform */ "./src/mapboxgl/layer/threejs/Transform.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return _Transform__WEBPACK_IMPORTED_MODULE_1__["Transform"]; });\n\n\n\n\n//# sourceURL=webpack:///./src/mapboxgl/layer/threejs/index.js?')},"./src/mapboxgl/services/FeatureService.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FeatureService", function() { return FeatureService; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ "./src/mapboxgl/core/Base.js");\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ "./src/mapboxgl/services/ServiceBase.js");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Util */ "./src/mapboxgl/core/Util.js");\n/* harmony import */ var _core_Parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Parse */ "./src/mapboxgl/core/Parse.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.FeatureService\r\n * @category  BaseType Service\r\n * @classdesc FeatureService.\r\n * @example\r\n * var featureService = new mapboxgl.ekmap.FeatureService({\r\n *      url : //The URL to the Feature Service\r\n * });\r\n * featureService.query(params,function(result){\r\n *     //doSomething\r\n * })\r\n * @extends {mapboxgl.ekmap.ServiceBase}\r\n * @param {object} options Construction parameters.\r\n * @param {string} options.url  (Required) The URL to the Feature Service.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n */\n\nvar FeatureService = /*#__PURE__*/function (_ServiceBase) {\n  _inherits(FeatureService, _ServiceBase);\n\n  var _super = _createSuper(FeatureService);\n\n  function FeatureService(options) {\n    var _this;\n\n    _classCallCheck(this, FeatureService);\n\n    _this = _super.call(this, options);\n\n    if (options.url) {\n      _this.options = _core_Util__WEBPACK_IMPORTED_MODULE_3__["Util"].getUrlParams(options);\n    }\n\n    return _this;\n  }\n\n  _createClass(FeatureService, [{\n    key: "nearby",\n    value: function nearby(lngLat, callback, context) {\n      var params = {};\n      params.geometry = [lngLat.lng, lngLat.lat];\n      params.geometryType = \'esriGeometryPoint\';\n      params.spatialRel = \'esriSpatialRelIntersects\';\n      params.units = \'esriSRUnit_Kilometer\';\n      params.distance = 5;\n      params.inSr = 4326;\n      params.returnIdsOnly = true;\n      params.f = \'json\';\n      var service = new FeatureService(this.options);\n      return service.request(\'query\', params, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.FeatureService.prototype.run\r\n     * @description  Executes the identify request with the current parameters, identified features will be passed to callback as a GeoJSON FeatureCollection. Accepts an optional function context.\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: "run",\n    value: function run(callback, context) {\n      this._cleanParams();\n\n      var service = new FeatureService(this.options); // services hosted on ArcGIS Online and ArcGIS Server 10.3.1+ support requesting geojson directly\n\n      if (this.options.isModern || isArcgisOnline(this.options.url)) {\n        this.params.f = \'geojson\';\n        return service.request(\'query\', params, function (error, response) {\n          this._trapSQLerrors(error);\n\n          callback.call(context, error, response, response);\n        }, this); // otherwise convert it in the callback then pass it on\n      } else {\n        return service.request(\'query\', params, function (error, response) {\n          this._trapSQLerrors(error);\n\n          callback.call(context, error, response && responseToFeatureCollection(response), response);\n        }, this);\n      }\n    }\n    /**\r\n     * @function mapboxgl.ekmap.FeatureService.prototype.addFeature\r\n     * @description Adds a new feature to the feature layer. this also adds the feature to the map if creation is successful.\r\n     * @param {GeoJSONObject} params GeoJSON of feature add (To change point color, set \'color\' for options GeoJSON, the default is light blue (\'#3FB1CE\')).\r\n     * @param {Function} callback\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: "addFeature",\n    value: function addFeature(params, callback, context) {\n      this.addFeatures(params, callback, context);\n    }\n    /**\r\n     * @private\r\n     * @function mapboxgl.ekmap.FeatureService.prototype.addFeatures\r\n     * @description Adds a new feature to the feature layer. this also adds the feature to the map if creation is successful.\r\n     * @param {GeoJSONObject} params GeoJSON of feature add (To change point color, set \'color\' for options GeoJSON, the default is light blue (\'#3FB1CE\')).\r\n     * @param {Function} callback\r\n     * @param {Object} context\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: "addFeatures",\n    value: function addFeatures(params, callback, context) {\n      var fea = _core_Parse__WEBPACK_IMPORTED_MODULE_4__["Parse"].geojsonToArcGIS(params);\n      var data = [];\n      data.push(fea);\n      var dataPost = JSON.stringify(data);\n      var service = new FeatureService(this.options);\n      return service.post(\'addFeatures\', dataPost, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n    * @function mapboxgl.ekmap.FeatureService.prototype.updateFeature\r\n    * @description Update the provided feature on the Feature Layer. This also updates the feature on the map.\r\n    * @param {GeoJSONObject} params Infomation feature.\r\n    * @param {Function} callback The callback of result data returned by the server side.\r\n    * @param {Object} context\r\n    * @returns {this}\r\n    */\n\n  }, {\n    key: "updateFeature",\n    value: function updateFeature(params, callback, context) {\n      this.updateFeatures(params, callback, context);\n    }\n    /**\r\n    * @private\r\n    * @function mapboxgl.ekmap.FeatureService.prototype.updateFeatures\r\n    * @description Update the provided feature on the Feature Layer. This also updates the feature on the map.\r\n    * @param {GeoJSONObject} params - Infomation feature.\r\n    */\n\n  }, {\n    key: "updateFeatures",\n    value: function updateFeatures(params, callback, context) {\n      var fea = _core_Parse__WEBPACK_IMPORTED_MODULE_4__["Parse"].geojsonToArcGIS(params);\n      var data = [];\n      data.push(fea);\n      var dataPost = JSON.stringify(data);\n      var service = new FeatureService(this.options);\n      return service.post(\'updateFeatures\', dataPost, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n    * @function mapboxgl.ekmap.FeatureService.prototype.deleteFeature\r\n    * @description Remove the feature with the provided id from the feature layer. This will also remove the feature from the map if it exists.\r\n    * @param {Interger} id Id of feature.\r\n    * @param {Function} callback The callback of result data returned by the server side.\r\n    * @param {Object} context\r\n    * @returns {this}\r\n    */\n\n  }, {\n    key: "deleteFeature",\n    value: function deleteFeature(id, callback, context) {\n      this.deleteFeatures(id, callback, context);\n    }\n    /**\r\n    * @function mapboxgl.ekmap.FeatureService.prototype.deleteFeatures\r\n    * @description Removes an array of features with the provided ids from the feature layer. This will also remove the features from the map if they exist.\r\n    * @param {Integers} ids List id of features.\r\n    * @param {Function} callback The callback of result data returned by the server side.\r\n    * @param {Object} context\r\n    * @returns {this}\r\n    */\n\n  }, {\n    key: "deleteFeatures",\n    value: function deleteFeatures(ids, callback, context) {\n      var service = new FeatureService(this.options);\n      return service.post(\'deleteFeatures\', ids, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.FeatureService.prototype.query\r\n     * @description Query data\r\n     * @param {Object} params - Adds the layer to the given map or layer group.\r\n     * @param {RequestCallback} callback\r\n     */\n\n  }, {\n    key: "query",\n    value: function query(params, callback, context) {\n      var param = {};\n      param.where = params.where;\n      if (params.orderByFields) param.orderByFields = params.orderByFields;\n\n      if (params.geometry) {\n        var geom = params.geometry;\n\n        if (params.geometry.type == \'Point\') {\n          param.geometryType = \'esriGeometryPoint\';\n          param.geometry = {\n            "x": geom.coordinates[0],\n            "y": geom.coordinates[1],\n            "spatialReference": {\n              "wkid": 4326\n            }\n          };\n        }\n\n        if (params.geometry.type == \'Polygon\') {\n          param.geometryType = \'esriGeometryPolygon\';\n          param.geometry = {\n            "rings": geom.coordinates,\n            "spatialReference": {\n              "wkid": 4326\n            }\n          };\n        }\n\n        if (params.geometry.type == \'LineString\') param.geometryType = \'esriGeometryPolyline\';\n      }\n\n      param.outFields = \'*\';\n      param.f = \'geojson\';\n      param.returnGeometry = true;\n      var service = new FeatureService(this.options);\n      return service.request(\'query\', param, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.FeatureService.prototype.queryByBound\r\n     * @description  is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {mapboxgl.LngLatBounds} lngLatBounds\r\n     * @param {RequestCallback} callback\r\n     */\n\n  }, {\n    key: "queryByBound",\n    value: function queryByBound(lngLatBounds, callback, context) {\n      var param = {};\n\n      var data = _core_Util__WEBPACK_IMPORTED_MODULE_3__["Util"]._setGeometry(lngLatBounds);\n\n      param.f = \'geojson\';\n      param.outFields = \'*\';\n      param.geometryType = data.geometryType;\n      param.geometry = data.geometry;\n      var service = new FeatureService(this.options);\n      return service.request(\'query\', param, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.FeatureService.prototype.queryByGeometry\r\n     * @description  is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {Object} geometry The geometry to apply as the spatial filter. The structure of the geometry is the same as the structure of the JSON geometry objects returned by the ArcGIS REST API. In addition to the JSON structures, for envelopes and points, you can specify the geometry with a simpler comma-separated syntax.\r\n     * @param {RequestCallback} callback\r\n     */\n\n  }, {\n    key: "queryByGeometry",\n    value: function queryByGeometry(params, callback, context) {\n      var param = {};\n      param.f = \'geojson\';\n      param.outFields = \'*\';\n\n      if (params) {\n        var geom = params;\n\n        if (params.type == \'Point\') {\n          param.geometryType = \'esriGeometryPoint\';\n          param.geometry = {\n            "x": geom.coordinates[0],\n            "y": geom.coordinates[1],\n            "spatialReference": {\n              "wkid": 4326\n            }\n          };\n        }\n\n        if (params.type == \'Polygon\') {\n          param.geometryType = \'esriGeometryPolygon\';\n          param.geometry = {\n            "rings": geom.coordinates,\n            "spatialReference": {\n              "wkid": 4326\n            }\n          };\n        }\n\n        if (params.type == \'LineString\') param.geometryType = \'esriGeometryPolyline\';\n      }\n\n      var service = new FeatureService(this.options);\n      return service.request(\'query\', param, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.FeatureService.prototype.applyEdits\r\n     * @description This operation adds, updates, and deletes features to the associated feature layer.\r\n     * @param {Object} params Options.\r\n     * @param {GeoJSONObject} params.adds GeoJSON of feature add.\r\n     * @param {GeoJSONObject} params.updates GeoJSON of feature update.\r\n     * @param {Interger} params.deletes Id of feature delete.\r\n     * @param {RequestCallback} callback\r\n     */\n\n  }, {\n    key: "applyEdits",\n    value: function applyEdits(params, callback, context) {\n      var param = {};\n\n      if (params.adds) {\n        var dataAdd = _core_Parse__WEBPACK_IMPORTED_MODULE_4__["Parse"].geojsonToArcGIS(params.adds);\n        var arr1 = [];\n        arr1.push(dataAdd);\n        param.adds = JSON.stringify(arr1);\n      } else param.adds = false;\n\n      if (params.updates) {\n        var dataUpdate = _core_Parse__WEBPACK_IMPORTED_MODULE_4__["Parse"].geojsonToArcGIS(params.updates);\n        var arr2 = [];\n        arr2.push(dataUpdate);\n        param.updates = JSON.stringify(arr2);\n      } else param.updates = false;\n\n      if (params.deletes) param.deletes = params.deletes;else param.deletes = false;\n      var service = new FeatureService(this.options);\n      console.log(param);\n      return service.post(\'applyEdits\', param, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n  }]);\n\n  return FeatureService;\n}(_ServiceBase__WEBPACK_IMPORTED_MODULE_2__["ServiceBase"]);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.FeatureService = FeatureService;\n\n//# sourceURL=webpack:///./src/mapboxgl/services/FeatureService.js?')},"./src/mapboxgl/services/IdentifyFeatures.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdentifyFeatures", function() { return IdentifyFeatures; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ "./src/mapboxgl/core/Base.js");\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ "./src/mapboxgl/services/ServiceBase.js");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Util */ "./src/mapboxgl/core/Util.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.IdentifyFeatures\r\n * @category  BaseType Service\r\n * @classdesc  mapboxgl.ekmap.IdentifyFeatures is an abstraction for the Identify API found in Map Services. It provides a chainable API for building request parameters and executing the request.\r\n * @extends {mapboxgl.ekmap.ServiceBase}\r\n * @param {object} options Construction parameters.\r\n * @param {string} options.url URL of the ArcGIS service you would like to consume.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n * @example\r\n * var map = new mapboxgl.Map({\r\n *      container: \'divMapId\',\r\n *      center: [103.9, 22.2],\r\n *      zoom: 6\r\n * })\r\n * var identify = new mapboxgl.ekmap.IdentifyFeatures({\r\n *      url: \'https://viegisserver.ekgis.vn/gserver/rest/services/35/MapServer\'\r\n * })\r\n *   .on(map)\r\n *   .at([])\r\n *   .run(function (obj) {\r\n *      console.log();\r\n *   })\r\n *     //doSomething\r\n * })\r\n */\n\nvar IdentifyFeatures = /*#__PURE__*/function (_ServiceBase) {\n  _inherits(IdentifyFeatures, _ServiceBase);\n\n  var _super = _createSuper(IdentifyFeatures);\n\n  function IdentifyFeatures(options) {\n    var _this;\n\n    _classCallCheck(this, IdentifyFeatures);\n\n    _this = _super.call(this, options);\n    if (options.url) _this.options = _core_Util__WEBPACK_IMPORTED_MODULE_3__["Util"].getUrlParams(options);\n    _this.paramsIdentify = {\n      geometry: \'\',\n      sr: 4326,\n      layers: \'all\',\n      tolerance: 6,\n      returnGeometry: true,\n      f: \'json\'\n    };\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.IdentifyFeatures.prototype.on\r\n   * @description  The map to identify features on.\r\n   * @param {mapboxgl.Map} map The map is defined.\r\n   * @returns {this}\r\n   */\n\n\n  _createClass(IdentifyFeatures, [{\n    key: "on",\n    value: function on(map) {\n      var bounds = new mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.LngLatBounds(map.getBounds()._sw, map.getBounds()._ne);\n      var extent = {\n        \'xmin\': bounds.getSouthWest().lng,\n        \'ymin\': bounds.getSouthWest().lat,\n        \'xmax\': bounds.getNorthEast().lng,\n        \'ymax\': bounds.getNorthEast().lat,\n        \'spatialReference\': {\n          \'wkid\': 4326\n        }\n      };\n      var size = map.getContainer();\n      this.paramsIdentify.imageDisplay = [size.clientWidth, size.clientHeight, 96];\n      this.paramsIdentify.mapExtent = [extent.xmin, extent.ymin, extent.xmax, extent.ymax];\n      return this;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.IdentifyFeatures.prototype.at\r\n     * @description  Identifies features at a given {@link https://docs.mapbox.com/mapbox-gl-js/api/geography/#lnglatbounds|mapboxgl.LatLngBounds} or a valid GeoJSON object literal.\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: "at",\n    value: function at(geometry) {\n      if (geometry.length === 2) geometry = new mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.LngLat(geometry);\n\n      this._setGeometryParams(geometry);\n\n      return this;\n    }\n    /**\r\n     * @function mapboxgl.ekmap.IdentifyFeatures.prototype.run\r\n     * @description  Executes the identify request with the current parameters, identified features will be passed to callback as a GeoJSON FeatureCollection. Accepts an optional function context.\r\n     * @returns {this}\r\n     */\n\n  }, {\n    key: "run",\n    value: function run(callback, context) {\n      var service = new IdentifyFeatures(this.options);\n      return service.request(\'identify\', this.paramsIdentify, function (error, response) {\n        // immediately invoke with an error\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @private\r\n     * @function mapboxgl.ekmap.IdentifyFeatures.prototype._setGeometryParams\r\n     * @description Set geometry params.\r\n     */\n\n  }, {\n    key: "_setGeometryParams",\n    value: function _setGeometryParams(geometry) {\n      var converted = _core_Util__WEBPACK_IMPORTED_MODULE_3__["Util"]._setGeometry(geometry);\n\n      this.paramsIdentify.geometry = converted.geometry;\n      this.paramsIdentify.geometryType = converted.geometryType;\n    }\n  }]);\n\n  return IdentifyFeatures;\n}(_ServiceBase__WEBPACK_IMPORTED_MODULE_2__["ServiceBase"]);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.IdentifyFeatures = IdentifyFeatures;\n\n//# sourceURL=webpack:///./src/mapboxgl/services/IdentifyFeatures.js?')},"./src/mapboxgl/services/MapService.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapService", function() { return MapService; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ "./src/mapboxgl/core/Base.js");\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ "./src/mapboxgl/services/ServiceBase.js");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Util */ "./src/mapboxgl/core/Util.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.MapService\r\n * @category  BaseType Service\r\n * @classdesc The MapService class.\r\n * @extends {mapboxgl.ekmap.ServiceBase}\r\n * @param {object} options Construction parameters.\r\n * @param {string} options.url (Required) The URL to the MapService.\r\n * @param {string} options.token Will use this token to authenticate all calls to the service.\r\n * @example\r\n * var mapService = new mapboxgl.ekmap.MapService({\r\n *      url: //The URL to the MapService\r\n * });\r\n * mapService.identify(function(result){\r\n *     //doSomething\r\n * })\r\n */\n\nvar MapService = /*#__PURE__*/function (_ServiceBase) {\n  _inherits(MapService, _ServiceBase);\n\n  var _super = _createSuper(MapService);\n\n  function MapService(options) {\n    var _this;\n\n    _classCallCheck(this, MapService);\n\n    _this = _super.call(this, options);\n    _this.options = _core_Util__WEBPACK_IMPORTED_MODULE_3__["Util"].getUrlParams(options);\n    _this.paramsIdentify = {\n      geometry: \'\',\n      sr: 4326,\n      layers: \'all\',\n      tolerance: 3,\n      returnGeometry: true\n    };\n    return _this;\n  }\n  /**\r\n   * @function mapboxgl.ekmap.MapService.prototype.identify\r\n   * @description Returns a new mapboxgl.ekmap.IdentifyFeatures object that can be used to identify features contained within this service.\r\n   */\n\n\n  _createClass(MapService, [{\n    key: "identify",\n    value: function identify() {\n      return new mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.IdentifyFeatures(this.options);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.MapService.prototype.find\r\n     * @description  Is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.\r\n     * @param {Object} params\r\n     * @param {string} params.f=json The response format. The default response format is html.\r\n     * @param {string} params.searchText (Required) The search string. This is the text that is searched across the layers and fields the user specifies.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: "find",\n    value: function find(params, callback, context) {\n      var me = this;\n      this.legend(function (obj) {\n        var layers = [];\n        var list = obj.layers;\n        list.forEach(function (layer) {\n          layers.push(layer.layerId);\n        });\n        var param = {};\n        param.searchText = params.searchText;\n        param.layers = layers.toString();\n        param.f = \'json\';\n        var service = new MapService(me.options);\n        return service.request(\'find\', param, function (error, response) {\n          callback.call(context, error, response, response);\n        }, me);\n      });\n    }\n    /**\r\n     * @function mapboxgl.ekmap.MapService.prototype.query\r\n     * @description  Is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {Object} params\r\n     * @param {string} params.f=json The response format. The default response format is json.\r\n     * @param {string} params.where A WHERE clause for the query filter. Any legal SQL WHERE clause operating on the fields in the layer is allowed.\r\n     * @param {string} params.text A literal search text. If the layer has a display field associated with it, the server searches for this text in this field. This parameter is shorthand for a WHERE clause of where <displayField> like \'%<text>%\'. The text is case sensitive. This parameter is ignored if the WHERE parameter is specified.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: "query",\n    value: function query(params, callback, context) {\n      var param = {};\n      param.where = params.where;\n      param.text = params.text;\n      param.objectIds = params.objectId;\n      param.f = \'json\';\n      var service = new MapService(this.options);\n      return service.request(\'query\', param, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.MapService.prototype.getLayers\r\n     * @description  Get list layer on map. \r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: "getLayers",\n    value: function getLayers(callback, context) {\n      var params = {};\n      params.f = \'pjson\';\n      var service = new MapService(this.options);\n      return service.request(\'layers\', params, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.MapService.prototype.legend\r\n     * @description  Get legend on map.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: "legend",\n    value: function legend(callback, context) {\n      var params = {};\n      params.f = \'json\';\n      var service = new MapService(this.options);\n      return service.request(\'legend\', params, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.MapService.prototype.queryByBound\r\n     * @description  Is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {mapboxgl.LngLatBounds} lngLatBounds\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: "queryByBound",\n    value: function queryByBound(params, callback, context) {\n      var param = {};\n\n      var data = _core_Util__WEBPACK_IMPORTED_MODULE_3__["Util"]._setGeometry(params);\n\n      param.f = \'geojson\';\n      param.geometryType = data.geometryType;\n      param.geometry = data.geometry;\n      var service = new MapService(this.options);\n      return service.request(\'query\', param, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n    /**\r\n     * @function mapboxgl.ekmap.MapService.prototype.queryByGeometry\r\n     * @description  Is an abstraction for the find API included in Map Services. It provides a chainable API for building request parameters and executing find tasks.。\r\n     * @param {Object} geometry The geometry to apply as the spatial filter. The structure of the geometry is the same as the structure of the JSON geometry objects returned by the ArcGIS REST API. In addition to the JSON structures, for envelopes and points, you can specify the geometry with a simpler comma-separated syntax.\r\n     * @param {RequestCallback} callback The callback of result data returned by the server side.\r\n     */\n\n  }, {\n    key: "queryByGeometry",\n    value: function queryByGeometry(params, callback, context) {\n      var param = {};\n      param.f = \'geojson\';\n\n      if (params) {\n        var geom = params;\n\n        if (params.type == \'Point\') {\n          param.geometryType = \'esriGeometryPoint\';\n          param.geometry = {\n            "x": geom.coordinates[0],\n            "y": geom.coordinates[1],\n            "spatialReference": {\n              "wkid": 4326\n            }\n          };\n        }\n\n        if (params.type == \'Polygon\') {\n          param.geometryType = \'esriGeometryPolygon\';\n          param.geometry = {\n            "rings": geom.coordinates,\n            "spatialReference": {\n              "wkid": 4326\n            }\n          };\n        }\n\n        if (params.type == \'LineString\') param.geometryType = \'esriGeometryPolyline\';\n      }\n\n      var service = new MapService(this.options);\n      return service.request(\'query\', param, function (error, response) {\n        callback.call(context, error, response, response);\n      }, this);\n    }\n  }]);\n\n  return MapService;\n}(_ServiceBase__WEBPACK_IMPORTED_MODULE_2__["ServiceBase"]);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.MapService = MapService;\n\n//# sourceURL=webpack:///./src/mapboxgl/services/MapService.js?')},"./src/mapboxgl/services/ServiceBase.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ServiceBase", function() { return ServiceBase; });\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mapbox-gl */ "mapbox-gl");\n/* harmony import */ var mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Base */ "./src/mapboxgl/core/Base.js");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Util */ "./src/mapboxgl/core/Util.js");\n/* harmony import */ var _core_Request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Request */ "./src/mapboxgl/core/Request.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n/**\r\n * @class mapboxgl.ekmap.ServiceBase\r\n * @category  BaseType Service\r\n * @description mapboxgl.ekmap base class.\r\n * @param {Object} options The optional parameters.\r\n * @param {string} options.url (Required) The URL to the MapService.\r\n * @param {string} options.token - Will use this token to authenticate all calls to the service.\r\n */\n\nvar ServiceBase = /*#__PURE__*/function (_mapboxgl$Evented) {\n  _inherits(ServiceBase, _mapboxgl$Evented);\n\n  var _super = _createSuper(ServiceBase);\n\n  function ServiceBase(options) {\n    var _this;\n\n    _classCallCheck(this, ServiceBase);\n\n    _this = _super.call(this, options);\n    _this.options = _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].getUrlParams(options);\n    _this.url = _this.options.url;\n    /**\r\n     * @event mapboxgl.ekmap.ServiceBase#initialized\r\n     * @description .\r\n     * @property {Object} this this .\r\n     */\n\n    _this.fire(\'initialized\', _assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  _createClass(ServiceBase, [{\n    key: "request",\n    value: function request(path, params, callback, context) {\n      return this._request(path, params, callback, context);\n    }\n  }, {\n    key: "_request",\n    value: function _request(path, params, callback, context) {\n      this.fire(\'requeststart\', {\n        url: this.url + path,\n        params: params\n      }, true);\n\n      if (this.options.token) {\n        params.token = this.options.token;\n      }\n\n      if (this.options.requestParams) {\n        _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].extend(params, this.options.requestParams);\n      }\n\n      if (this._authenticating) {\n        return;\n      } else {\n        var url = this.url + path;\n        return _core_Request__WEBPACK_IMPORTED_MODULE_3__["Request"].send(url + \'?\' + _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].serialize(params), "", {}, callback);\n      }\n    }\n  }, {\n    key: "post",\n    value: function post(path, dataPost, callback, context) {\n      return this._post(path, dataPost, callback, context);\n    }\n  }, {\n    key: "_post",\n    value: function _post(path, dataPost, callback, context) {\n      this.fire(\'poststart\', {\n        url: this.url + path,\n        dataPost: dataPost\n      }, true);\n\n      if (this.options.requestParams) {\n        _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].extend(dataPost, this.options.requestParams);\n      }\n\n      var data = {};\n\n      if (this.options.token) {\n        data.token = this.options.token;\n      }\n\n      if (this._authenticating) {\n        this._requestQueue.push([method, path, dataPost, callback, context]);\n\n        return;\n      } else {\n        var url = this.url + path;\n        return _core_Request__WEBPACK_IMPORTED_MODULE_3__["Request"].post(url + \'?\' + _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].serialize(data), dataPost, this.options, callback);\n      }\n    }\n  }, {\n    key: "_createServiceCallback",\n    value: function _createServiceCallback(method, path, params, callback, context) {\n      return _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].bind(function (error, response) {\n        if (error && (error.code === 499 || error.code === 498)) {\n          this._authenticating = true;\n\n          this._requestQueue.push([method, path, params, callback, context]); // fire an event for users to handle and re-authenticate\n\n\n          this.fire(\'authenticationrequired\', {\n            authenticate: _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].bind(this.authenticate, this)\n          }, true); // if the user has access to a callback they can handle the auth error\n\n          error.authenticate = _core_Util__WEBPACK_IMPORTED_MODULE_2__["Util"].bind(this.authenticate, this);\n        }\n\n        callback.call(context, error, response);\n\n        if (error) {\n          this.fire(\'requesterror\', {\n            url: this.options.url + path,\n            params: params,\n            message: error.message,\n            code: error.code,\n            method: method\n          }, true);\n        } else {\n          this.fire(\'requestsuccess\', {\n            url: this.options.url + path,\n            params: params,\n            response: response,\n            method: method\n          }, true);\n        }\n\n        this.fire(\'requestend\', {\n          url: this.options.url + path,\n          params: params,\n          method: method\n        }, true);\n      }, this);\n    }\n  }]);\n\n  return ServiceBase;\n}(mapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.Evented);\nmapbox_gl__WEBPACK_IMPORTED_MODULE_0___default.a.ekmap.ServiceBase = ServiceBase;\n\n//# sourceURL=webpack:///./src/mapboxgl/services/ServiceBase.js?')},"./src/mapboxgl/services/index.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _FeatureService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FeatureService */ "./src/mapboxgl/services/FeatureService.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FeatureService", function() { return _FeatureService__WEBPACK_IMPORTED_MODULE_0__["FeatureService"]; });\n\n/* harmony import */ var _MapService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapService */ "./src/mapboxgl/services/MapService.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MapService", function() { return _MapService__WEBPACK_IMPORTED_MODULE_1__["MapService"]; });\n\n/* harmony import */ var _ServiceBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ServiceBase */ "./src/mapboxgl/services/ServiceBase.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ServiceBase", function() { return _ServiceBase__WEBPACK_IMPORTED_MODULE_2__["ServiceBase"]; });\n\n/* harmony import */ var _IdentifyFeatures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./IdentifyFeatures */ "./src/mapboxgl/services/IdentifyFeatures.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IdentifyFeatures", function() { return _IdentifyFeatures__WEBPACK_IMPORTED_MODULE_3__["IdentifyFeatures"]; });\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/mapboxgl/services/index.js?')},0:function(module,exports,__webpack_require__){eval('__webpack_require__(/*! D:\\Dev\\eKMap\\eKMap-Client\\src\\mapboxgl\\index.js */"./src/mapboxgl/index.js");\nmodule.exports = __webpack_require__(/*! D:\\Dev\\eKMap\\eKMap-Client\\src\\mapboxgl\\css\\index.js */"./src/mapboxgl/css/index.js");\n\n\n//# sourceURL=webpack:///multi_./src/mapboxgl/index.js_./src/mapboxgl/css/index.js?')},"mapbox-gl":function(module,exports){eval("module.exports = mapboxgl;\n\n//# sourceURL=webpack:///external_%22mapboxgl%22?")},three:function(module,exports){eval("module.exports = function(){try{return THREE}catch(e){return {}}}();\n\n//# sourceURL=webpack:///external_%22function()%7Btry%7Breturn_THREE%7Dcatch(e)%7Breturn_%7B%7D%7D%7D()%22?")}});